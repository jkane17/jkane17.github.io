<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Q/KDB+ Blog</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Blogs for Q/KDB+">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/content-533a1c23.css">
        <link rel="stylesheet" href="theme/custom-highlight-00a73c7c.css">
        <link rel="stylesheet" href="theme/navigation-ccf6f99d.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-64b11320.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-d1cf8374.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Q/KDB+ Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="qkdb-blog"><a class="header" href="#qkdb-blog">Q/KDB+ Blog</a></h1>
<p>Welcome to the Q/KDB+ Blog. Here you‚Äôll find articles exploring various aspects of the Q programming language and KDB+ database.</p>
<h2 id="latest-articles"><a class="header" href="#latest-articles">Latest Articles</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Title</th><th>Published</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong><a href="#kdb-x-modules">KDB-X Modules</a></strong></td><td>Nov 25, 2025</td><td>Learn the basics of the KDB-X module system.</td></tr>
<tr><td><strong><a href="#performance-costs-of-kdb-attributes">Performance Costs of KDB+ Attributes</a></strong></td><td>Aug 15, 2025</td><td>Explore the performance costs that KDB+ attributes can have.</td></tr>
<tr><td><strong><a href="#performance-benefits-of-kdb-attributes">Performance Benefits of KDB+ Attributes</a></strong></td><td>Aug 4, 2025</td><td>See what performance benefits can be realised when using KDB+ attributes.</td></tr>
<tr><td><strong><a href="#kdb-attributes">KDB+ Attributes</a></strong></td><td>May 6, 2025</td><td>Understand the basics of attributes in KDB+.</td></tr>
<tr><td><strong><a href="#floating-point-datatypes-in-qkdb">Floating-Point Datatypes in Q/KDB+</a></strong></td><td>Feb 28, 2025</td><td>Master floating-point datatypes in Q.</td></tr>
<tr><td><strong><a href="#measuring-compression-performance-in-qkdb">Measuring Compression Performance in Q/KDB+</a></strong></td><td>Jan 31, 2025</td><td>Find out how to measure the performance of different compression algorithm and settings.</td></tr>
<tr><td><strong><a href="#an-introduction-to-compression-in-qkdb">An Introduction to Compression in Q/KDB+</a></strong></td><td>Oct 13, 2024</td><td>A detailed look at how compression works in Q.</td></tr>
<tr><td><strong><a href="#command-line-arguments-in-qkdb">Command Line Arguments in Q/KDB+</a></strong></td><td>Sep 20, 2024</td><td>Discover how to customise Q session behavior using command line arguments.</td></tr>
<tr><td><strong><a href="#an-introduction-to-interacting-with-rest-apis-in-qkdb">An Introduction to Interacting with REST APIs in Q/KDB+</a></strong></td><td>Sep 11, 2024</td><td>Learn how to interact with REST APIs using Q, including HTTP GET requests, HTTPS, and handling responses.</td></tr>
<tr><td><strong><a href="#the-little-q-keywords-that-could">The Little Q Keywords That Could</a></strong></td><td>Aug 15, 2024</td><td>Explore lesser-known and underutilised Q keywords that can be powerful when used effectively.</td></tr>
<tr><td><strong><a href="#analysis-of-q-memory-allocation">Analysis of Q Memory Allocation</a></strong></td><td>Aug 15, 2024</td><td>Delve into how Q handles memory allocation using the buddy memory allocation system.</td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kdb-x-modules"><a class="header" href="#kdb-x-modules">KDB-X Modules</a></h1>
<p><img src="images/kdbx_modules.png" title="Cover Image" alt="Cover Image"></p>
<p>Most modern programming languages provide a module system to support clean encapsulation, code reuse, and easy distribution of functionality. Q/KDB+, however, historically developed without such a system. Its smaller open-source ecosystem, combined with its primarily closed-source usage inside large financial institutions, meant that developers typically relied on manually copying small <code>.q</code> files directly into their projects.</p>
<p>But the Q/KDB+ ecosystem has matured. As its community grows and expectations align more closely with those of other modern languages, the need for a proper module system has become clear. With the introduction of KDB-X, that gap has finally been filled: modules are now a first-class part of the language.</p>
<p>In this blog, we‚Äôll explore the new KDB-X module system ‚Äî how it works, how to incorporate modules created by others into your own projects, and how to develop and share your own modules with the broader community.</p>
<h2 id="what-are-modules"><a class="header" href="#what-are-modules">What Are Modules?</a></h2>
<p>In KDB-X, a module is a self-contained unit of encapsulation: it has its own local namespace to hold functions, variables, and internal state, separate from the global q environment. Modules explicitly expose parts of their interface through an <code>export</code> dictionary, allowing other code to import and use only the intended elements via the <code>use</code> function. This design supports isolation (modules do not pollute the global namespace) and portability (each module lives in a well-defined file or directory structure).</p>
<h2 id="creating-a-module"><a class="header" href="#creating-a-module">Creating A Module</a></h2>
<p>To demonstrate how to build a module in KDB-X, let‚Äôs create a simple command-line argument parser called <code>clap.q</code>.</p>
<p>We‚Äôll start by defining a function to register command-line arguments. This function stores the argument name and associated metadata in a private table:</p>
<pre><code class="language-q">// Table to hold command line arguments.
args:([name:1#`] val:1#(); default:1#(); description:1#());

// Register a command line argument to be parsed.
register:{[name;default;description] 
    `args upsert ([name;default;description]);
 };
</code></pre>
<p>Here:</p>
<ul>
<li><code>name</code> - the argument name (provided as <code>-name</code> on the command line).</li>
<li><code>val</code> - the parsed value (set later when parsing).</li>
<li><code>default</code> - the default value if the argument is not supplied (see my <a href="#command-line-arguments-in-qkdb">previous blog</a> for details on how <code>.Q.def</code> handles defaults).</li>
<li><code>description</code> - a short human-readable description.</li>
</ul>
<p>To make <code>register</code> part of our public API, we export it. The <code>export</code> dictionary lists the functions or variables intended to be visible outside the module. Here we use the dictionary-literal syntax introduced in q 4.1:</p>
<pre><code class="language-q">export:([register]);
</code></pre>
<p>Next, the module must live somewhere on q‚Äôs module search path (see <a href="https://code.kx.com/kdb-x/modules/module-framework/quickstart.html#search-path">Search path</a> in the KDB-X documentation). You could add your own directories to <code>QPATH</code>, but for simplicity we‚Äôll copy <code>clap.q</code> into the default module directory:</p>
<pre><code class="language-bash">$ cp clap.q $QHOME/mod/qlib/.
</code></pre>
<p>I‚Äôm using a <code>qlib</code> subdirectory to keep my own modules organised, but any name works. From here on, we will edit <code>$QHOME/mod/qlib/clap.q</code> directly.</p>
<p>If <code>QHOME</code> is not set, it simply refers to the root of your KX installation‚Äîfor example: <code>/home/user/.kx/.</code></p>
<p>We can now load our module using the new <code>use</code> keyword:</p>
<pre><code class="language-q">q)show clap:use`qlib.clap
register| {[name;default;description]
    `args upsert ([name;default;description]);
 }
</code></pre>
<p>We see the exported <code>register</code> function, but not the private <code>args</code> table.</p>
<h3 id="registering-an-argument"><a class="header" href="#registering-an-argument">Registering an Argument</a></h3>
<p>Let‚Äôs register an argument:</p>
<pre><code class="language-q">q)clap.register[`myArg; 0; "My argument of long type"]
</code></pre>
<p>No error is signalled, but we currently have no way to confirm whether it worked.</p>
<p>To inspect things while developing, let‚Äôs temporarily expose <code>args</code> by adding it to export:</p>
<pre><code class="language-q">export:([args; register]);
</code></pre>
<p>Reloading in a new q session:</p>
<pre><code class="language-q">q)clap:use`qlib.clap

q)clap.register[`myArg; 0; "My argument of long type"]

q)clap.args
name| val default description
----| -----------------------
    |  
</code></pre>
<p>The table is still empty. This illustrates a key behaviour of the module system: <strong>exported values are copies, not references</strong>. The module‚Äôs private data remains private unless you expose explicit accessors.</p>
<p>Let‚Äôs add a getter:</p>
<pre><code class="language-q">// Get the args table.
getArgs:{[] args};

// Don't forget to export getArgs.
export:([getArgs; register]);
</code></pre>
<p>If we reload using <code>use</code>, nothing appears to change:</p>
<pre><code class="language-q">q)show clap:use`qlib.clap
args    | ...
register| ...
</code></pre>
<p>This is because q caches modules. Reloading with <code>use</code> will not re-run the module unless forced. To refresh a module in the current session without restarting q, use <code>.Q.m.reuse</code>:</p>
<pre><code class="language-q">q)show clap:.Q.m.reuse `qlib.clap
getArgs | {[] args}
register| ...
</code></pre>
<p>Now we see the updated exports.</p>
<p>Registering again (since the module was reloaded) and running the <code>getArgs</code> function:</p>
<pre><code class="language-q">q)clap.register[`myArg; 0; "My argument of long type"]

q)clap.getArgs[]
name| val default description
----| -----------------------
    |  
</code></pre>
<p>We still see an empty table. The problem is inside the <code>register</code> function itself.</p>
<p>When we wrote:</p>
<pre><code class="language-q">args upsert ...
</code></pre>
<p><code>args</code> resolves to a global variable, not the module‚Äôs private variable. Indeed:</p>
<pre><code class="language-q">q)args
name       | `myArg
default    | 0
description| "My argument of long type"
</code></pre>
<p>This is the row we attempted to upsert.</p>
<p>Inside module code, names appear global, but at runtime the module is wrapped in its own namespace. To modify the module‚Äôs internal state, we must assign back into the namespace explicitly:</p>
<pre><code class="language-q">register:{[name;default;description]
    args::args upsert ([name;default;description]);
 };
</code></pre>
<p>Trying again:</p>
<pre><code class="language-q">q)clap:.Q.m.reuse `qlib.clap

q)clap.getArgs[]                                         // Empty initially
name| val default description
----| -----------------------
    |                        

q)clap.register[`myArg; 0; "My argument of long type"]

q)clap.getArgs[]                                         // We now see the registered argument
name | val default description               
-----| --------------------------------------
     |     ()      ()                        
myArg|     0       "My argument of long type"
</code></pre>
<p>Now we see the expected row. The empty first row is simply a ‚Äútype-padding‚Äù row to prevent column type promotion (e.g., <code>val</code> and <code>default</code> may contain mixed types).</p>
<h3 id="parsing-the-command-line"><a class="header" href="#parsing-the-command-line">Parsing the Command-Line</a></h3>
<p>After registering arguments, we need to parse the command line. First, let‚Äôs add a utility to retrieve the raw parsed arguments:</p>
<pre><code class="language-q">// Get the raw command line values, organised into a dictionary (name-value pairs).
raw:{[] .Q.opt .z.X};

export:([getArgs; raw; register]);
</code></pre>
<p>Reload:</p>
<pre><code class="language-q">q)clap:.Q.m.reuse `qlib.clap

q)clap.raw[]
p| "5000"
</code></pre>
<p>Now restart q with more arguments:</p>
<pre><code class="language-bash">$ q -p 5000 -myArg1 10 -myArg2 hello
</code></pre>
<p>Then:</p>
<pre><code class="language-q">q)clap:use`qlib.clap

q)clap.raw[]
p     | "5000" 
myArg1| "10"   
myArg2| "hello
</code></pre>
<p>To parse arguments, we need to:</p>
<ol>
<li>Convert each supplied value to the correct type (falling back to the default when not supplied).</li>
<li>Update the <code>val</code> column in the <code>args</code> table.</li>
</ol>
<p>We‚Äôll add a <code>parse</code> function. Since <code>parse</code> is a reserved keyword in q, we define it inside the module namespace <code>.z.m</code>.</p>
<pre><code class="language-q">// Parse command line.
.z.m.parse:{[]
    args::args upsert flip `name`val!(key;value)@\:
        exec .Q.def[name!default;.z.m.raw[]] from args;
 };

export:([getArgs; .z.m.parse; raw; register]);
</code></pre>
<p>Reload and test:</p>
<pre><code class="language-q">q)clap:.Q.m.reuse `qlib.clap

q)clap.register[`myArg1; 0;   "Given argument of long type"]

q)clap.register[`myArg3; 0.0; "Not given argument of float type"]

q)clap.parse[]

q)clap.getArgs[]
name  | val      default description                       
------| ---------------------------------------------------
      | ()       ()      ()                                
myArg1| 10       0       "Given argument of long type"     
myArg3| 0f       0f      "Not given argument of float type"
p     | ,"5000"  ()      ()                                
myArg2| ,"hello" ()      ()
</code></pre>
<p>The results reflect:</p>
<ul>
<li><code>myArg1</code> ‚Üí value from the command line (<code>10</code>)</li>
<li><code>myArg3</code> ‚Üí default value (<code>0f</code>)</li>
<li><code>myArg2</code> and <code>p</code> ‚Üí present but unregistered, so they remain raw enlisted strings</li>
</ul>
<h3 id="a-public-accessor-api"><a class="header" href="#a-public-accessor-api">A Public Accessor API</a></h3>
<p><code>getArgs</code> has been useful for debugging but should not be part of a clean public API. Instead, let‚Äôs provide a simple accessor:</p>
<pre><code class="language-q">// Get the value of an argument.
.z.m.get:{[name] args[name;`val]};   // get is reserved, so use .z.m.get

export:([.z.m.get; .z.m.parse; raw; register]);
</code></pre>
<p>Example usage (after reload, re-register, and parse):</p>
<pre><code class="language-q">q)clap.get`myArg1
10

q)clap.get`myArg2
"hello"

q)clap.get`myArg3
0f

q)clap.get`p
"5000"

q)clap.get`nonExistingArg    // Returns ()
</code></pre>
<p>I‚Äôve added many more features to the <em>clap</em> module, which you can find here: <a href="https://github.com/jkane17/qlib/tree/main">jkane17/qlib</a>.</p>
<h2 id="sharing-your-modules"><a class="header" href="#sharing-your-modules">Sharing Your Modules</a></h2>
<p>As of now, KDB-X does not yet have a dedicated package registry, largely because the module system is still new and the ecosystem is relatively small. Sharing modules is therefore straightforward: publish your code on GitHub or any similar hosting platform, and users can download it and place it into their own <code>mod/</code> directory (or anywhere else on their configured module search path).</p>
<p>Note that while the only requirement for sharing a module is providing the q source file(s), it‚Äôs highly recommended to include documentation describing what the module does, how to use it, and any assumptions or dependencies it has. Clear documentation makes your module far easier for others to adopt, understand, and build upon.</p>
<h2 id="using-modules-from-others"><a class="header" href="#using-modules-from-others">Using Modules From Others</a></h2>
<p>KX ships a collection of official modules with every KDB-X installation, documented <a href="https://code.kx.com/kdb-x/modules/module-index.html#official-kx-modules">here</a>. The same page also catalogues a range of open-source modules, which are useful both as ready-made components and as examples of good module design. To use any external module, simply download its source files and place them somewhere on your module search path ‚Äî commonly within your <code>mod/</code> directory ‚Äî after which it can be imported with <code>use</code> like any other module.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The introduction of a module system in KDB-X marks an important step forward for the q ecosystem. Modules provide structure, encapsulation, and clarity ‚Äî allowing developers to build cleaner codebases, share functionality more easily, and avoid the common pitfalls of global namespaces. Although the ecosystem is still young and a centralised package registry has yet to emerge, the foundations are now in place for a more collaborative and reusable approach to q development.</p>
<p>Whether you are incorporating modules written by others or creating your own, the new system offers a practical, modern way to organise and distribute functionality. As the community continues to grow, shared modules and best practices will evolve alongside it. I hope this tutorial has given you a clear understanding of how KDB-X modules work and inspired you to start building and sharing your own.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-costs-of-kdb-attributes"><a class="header" href="#performance-costs-of-kdb-attributes">Performance Costs of KDB+ Attributes</a></h1>
<p><img src="images/attr_perf_costs.png" title="Cover Image" alt="Cover Image"></p>
<p>In my <a href="#performance-benefits-of-kdb-attributes">previous blog</a>, we explored how the four KDB+ attributes - <em>sorted</em>, <em>unique</em>, <em>parted</em>, and <em>grouped</em> - can significantly improve query performance by enabling optimised search and aggregation strategies. However, these performance gains are not without cost.</p>
<p>In this blog, we shift focus from performance gains to the performance costs associated with using attributes ‚Äî specifically, their time and memory overheads. While attributes can make queries faster, they can also introduce additional processing during data updates or loading, and consume extra memory to maintain internal indexing structures such as hash maps.</p>
<p>Through a series of targeted benchmarks and experiments, we‚Äôll measure these overheads and derive practical models to help you predict the trade-offs. Whether you‚Äôre building real-time systems or managing large volumes of historical data, understanding the full cost profile of attributes is key to making informed design decisions in KDB+.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>Results were generated using Q/KDB+ version 4.1 (2025.04.28).</p>
</blockquote>
<h2 id="complexity"><a class="header" href="#complexity">Complexity</a></h2>
<p>Firstly, there‚Äôs increased complexity in managing attributes. Certain list operations can remove an attribute, requiring developers to explicitly reapply it afterward. Failing to do so may result in unexpected performance regressions. It‚Äôs essential to be aware of such cases and apply proper safeguards.</p>
<p>More on attribute preservation is available in my <a href="#kdb-attributes">previous blog post</a>.</p>
<h2 id="time-overhead"><a class="header" href="#time-overhead">Time Overhead</a></h2>
<p>In addition to logical complexity, there‚Äôs a time cost involved when applying or maintaining attributes.</p>
<h3 id="applying-attributes"><a class="header" href="#applying-attributes">Applying Attributes</a></h3>
<p>Applying an attribute for the first time involves validation and setup work:</p>
<ul>
<li><em>sorted</em>, <em>unique</em>, and <em>parted</em> must verify order or uniqueness.</li>
<li><em>unique</em>, <em>parted</em>, and <em>grouped</em> require the creation of internal hash maps, which grow in size with the list.</li>
</ul>
<p>To quantify this, we apply each attribute to a list created using <code>til N</code> and measure the average time taken:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>Sorted (ms)</th><th>Unique (ms)</th><th>Parted (ms)</th><th>Grouped (ms)</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000429</td><td>0.0246</td><td>0.0586</td><td>0.0868</td></tr>
<tr><td>10,000</td><td>0.000291</td><td>0.234</td><td>0.556</td><td>0.965</td></tr>
<tr><td>100,000</td><td>0.000412</td><td>3.33</td><td>9.77</td><td>16.1</td></tr>
<tr><td>1,000,000</td><td>0.000438</td><td>38.5</td><td>86.5</td><td>155</td></tr>
<tr><td>10,000,000</td><td>0.000306</td><td>604</td><td>1100</td><td>1610</td></tr>
<tr><td>100,000,000</td><td>0.000796</td><td>8630</td><td>15600</td><td>28100</td></tr>
</tbody>
</table>
</div>
<p>These results show:</p>
<ul>
<li><em>sorted</em> is very fast to apply even for large lists.</li>
<li><em>unique</em>, <em>parted</em>, and especially <em>grouped</em> take significantly more time, due to the hash map construction.</li>
</ul>
<p>We repeat the test on lists of non-unique values, created using <code>N?N div 4</code>, to see how this affects performance:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>Sorted (ms)</th><th>Parted (ms)</th><th>Grouped (ms)</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000352</td><td>0.00540</td><td>0.0247</td></tr>
<tr><td>10,000</td><td>0.000335</td><td>0.0708</td><td>0.252</td></tr>
<tr><td>100,000</td><td>0.000329</td><td>1.13</td><td>3.00</td></tr>
<tr><td>1,000,000</td><td>0.000542</td><td>11.9</td><td>24.8</td></tr>
<tr><td>10,000,000</td><td>0.000610</td><td>304</td><td>457</td></tr>
<tr><td>100,000,000</td><td>0.000357</td><td>2920</td><td>4590</td></tr>
</tbody>
</table>
</div>
<p>For a non-unique list, applying <em>parted</em> and <em>grouped</em> is faster ‚Äî likely due to fewer unique keys, leading to smaller hash maps and lower memory requirements.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>If attributes are applied once at system start-up, these times are usually negligible. But, if attributes must be reapplied repeatedly ‚Äî such as after frequent modifications ‚Äî they can introduce real overhead.</p>
</blockquote>
<h3 id="maintaining-attributes"><a class="header" href="#maintaining-attributes">Maintaining Attributes</a></h3>
<p>If you append to a list with an existing attribute and preserve the required structure (e.g., sorted order), the attribute is retained. However, maintaining it still incurs a performance cost, especially due to structure checks and hash map updates.</p>
<p>We measure the average append time over multiple appends, where each append added 1,000 elements until the list reached 100 million elements.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Average Append Time (ms)</th></tr>
</thead>
<tbody>
<tr><td>None</td><td>0.0102</td></tr>
<tr><td>Sorted</td><td>0.0117</td></tr>
<tr><td>Unique</td><td>0.323</td></tr>
<tr><td>Parted</td><td>0.0119</td></tr>
<tr><td>Grouped</td><td>0.680</td></tr>
</tbody>
</table>
</div>
<p>The test was also repeated for 100,000 elements appends.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Average Append Time (ms)</th></tr>
</thead>
<tbody>
<tr><td>None</td><td>0.648</td></tr>
<tr><td>Sorted</td><td>1.08</td></tr>
<tr><td>Unique</td><td>44.8</td></tr>
<tr><td>Parted</td><td>0.987</td></tr>
<tr><td>Grouped</td><td>84.5</td></tr>
</tbody>
</table>
</div>
<p>These results show that:</p>
<ul>
<li><em>Grouped</em> and <em>unique</em> are most expensive to maintain during appends, largely due to hash map maintenance and uniqueness checks respectively.</li>
<li>Larger appends incur a larger time cost.</li>
</ul>
<h2 id="space-overhead"><a class="header" href="#space-overhead">Space Overhead</a></h2>
<p>In addition to time costs, attributes (except for <em>sorted</em>) also introduce space overhead.</p>
<p>The <em>unique</em>, <em>parted</em>, and <em>grouped</em> attributes each maintain an internal hash map to support fast access, which increases memory usage. The size of this overhead depends on the list count and/or the count of unique elements.</p>
<p>To measure this overhead, we use the following procedure:</p>
<ol>
<li>Create a list.</li>
<li>Save it to disk.</li>
<li>Record the file size using <code>hcount</code>.</li>
<li>Apply the attribute.</li>
<li>Record the new file size using <code>hcount</code>.</li>
<li>Subtract the original size to calculate the overhead.</li>
</ol>
<h3 id="unique"><a class="header" href="#unique">Unique</a></h3>
<p>The overhead introduced by the <em>unique</em> attribute depends solely on the count of the list, regardless of the data values.</p>
<p>We measured this by applying the <em>unique</em> attribute to lists of increasing count (1 to 10,000 elements), and plotted the results:</p>
<p><img src="../images/unique_attr_overhead.png" title="Impact of List Count on Unique Attribute Overhead" alt="Impact of List Count on Unique Attribute Overhead"></p>
<p>The resulting step-wise growth pattern occurs because KDB+ uses a buddy memory allocation system. When the current memory block is insufficient for the hash map, the system allocates a new block twice as large, causing jumps in overhead.</p>
<p>Interestingly, within each step, the overhead decreases linearly as list count increases ‚Äî likely due to more efficient packing of the hash structure relative to the allocated memory.</p>
<p>A portion of the data is shown below:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>Overhead (Bytes)</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>0</td></tr>
<tr><td><strong>1</strong></td><td><strong>16</strong></td></tr>
<tr><td><strong>2</strong></td><td><strong>32</strong></td></tr>
<tr><td>3</td><td>72</td></tr>
<tr><td><strong>4</strong></td><td><strong>64</strong></td></tr>
<tr><td>5</td><td>152</td></tr>
<tr><td>6</td><td>144</td></tr>
<tr><td>7</td><td>136</td></tr>
<tr><td><strong>8</strong></td><td><strong>128</strong></td></tr>
<tr><td>9</td><td>312</td></tr>
<tr><td>..</td><td>..</td></tr>
<tr><td><strong>16</strong></td><td><strong>256</strong></td></tr>
<tr><td>17</td><td>632</td></tr>
<tr><td>..</td><td>..</td></tr>
</tbody>
</table>
</div>
<p><strong>Deriving a Formula</strong></p>
<p>To generalise the memory overhead of the <em>unique</em> attribute, we begin by defining <em>p</em> as the next power of 2 greater than or equal to the list count <em>n</em>:</p>
<p>\[
p = 2 ^ {\lceil \log_{2}{n} \rceil}
\]</p>
<p>From the observed data, we note that whenever the list count <em>n</em> is an exact power of 2 (e.g., 1, 2, 4, 8, 16‚Ä¶), the overhead aligns with:</p>
<p>\[
\text{overhead} = 16n \quad \text{where} \space \space n = 2^k, \space \space k \in \mathbb{Z}_{\ge 0}
\]</p>
<p>This gives us the base overhead at each power-of-2 boundary. Between those boundaries ‚Äî that is, for values of <em>n</em> such that \(n \in (p/2, p)\) ‚Äî the overhead decreases by 8 bytes for every step closer to <em>p</em>. This decreasing pattern suggests the adjustment term:</p>
<p>\[
8(n - p)
\]</p>
<p>To express the general formula for any list count <em>n</em>, we substitute the fixed power-of-2 overhead (<em>16n</em>) with <em>16p</em>, since <em>p</em> is the power of 2 the list will eventually ‚Äúgrow into‚Äù. Applying the adjustment term, the formula becomes:</p>
<p>\[
\begin{align*}
\text{overhead} &amp;= 16p - 8(n - p) \\
&amp;= 8(3p - n)
\end{align*}
\]</p>
<p>This can be computed in Q with:</p>
<pre><code class="language-q">nextPower2:{[n] "j"$2 xexp ceiling 2 xlog n}

uniqueOverhead:{[n] 8*(3*nextPower2 n)-n}
</code></pre>
<p>Example usage:</p>
<pre><code class="language-q">q)uniqueOverhead 1+til 10
16 32 72 64 152 144 136 128 312 304
</code></pre>
<h3 id="parted"><a class="header" href="#parted">Parted</a></h3>
<p>The overhead of the <em>parted</em> attribute depends primarily on the count of unique elements in the list. This is because the internal hash map stores each unique value along with the index of its first occurrence.</p>
<p>To analyse this, we tested 10,000-element lists with varying counts of unique values, from 1 to 10,000.</p>
<p><img src="../images/parted_attr_overhead.png" title="Impact of Unique Value Count on Parted Attribute Overhead" alt="Impact of Unique Value Count on Parted Attribute Overhead"></p>
<p>As with the <em>unique</em> attribute, we observe a step pattern, which results from KDB+ allocating memory in powers of 2 (buddy allocation system).</p>
<p>Between each step, the overhead increases linearly with the count of unique values.</p>
<p>A portion of the results is shown below:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Count of Unique Values</th><th>Overhead (Bytes)</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>72</td></tr>
<tr><td>2</td><td>104</td></tr>
<tr><td>3</td><td>160</td></tr>
<tr><td>4</td><td>168</td></tr>
<tr><td>5</td><td>272</td></tr>
<tr><td>6</td><td>280</td></tr>
<tr><td>7</td><td>288</td></tr>
<tr><td>8</td><td>296</td></tr>
<tr><td>9</td><td>496</td></tr>
<tr><td>..</td><td>..</td></tr>
<tr><td>15</td><td>544</td></tr>
<tr><td>16</td><td>552</td></tr>
<tr><td>17</td><td>944</td></tr>
<tr><td>..</td><td>..</td></tr>
</tbody>
</table>
</div>
<p>From this table, we see that at powers of 2 (1, 2, 4, 8, 16), the overheads are:</p>
<pre><code>u:           1  2   4   8   16
overhead:    72 104 168 296 552
</code></pre>
<p>Subtracting a constant base of 40 bytes (likely fixed overhead for the hash structure) gives:</p>
<pre><code>32, 64, 128, 256, 512 = 32 √ó (1, 2, 4, 8, 16)
</code></pre>
<p>This suggests the overhead at powers of 2 follows:</p>
<p>\[
\text{overhead} = 40 + 32p
\]</p>
<p>where</p>
<p>\[
p = 2 ^ {\lceil \log_{2}{u} \rceil}
\]</p>
<p>and <em>u</em> is the count of unique values in the list.</p>
<p><strong>General Formula</strong></p>
<p>For non-power-of-2 <em>u</em>, we observe that the overhead increases by 8 bytes with each additional unique value until the next power-of-2 threshold. This incremental cost can be modelled as:</p>
<p>\[
8(u - p)
\]</p>
<p>Putting it all together, the complete formula becomes:</p>
<p>\[
\begin{align*}
\text{overhead} &amp;= 40 + 32p + 8(u - p) \\
&amp;= 8(3p + u + 5)
\end{align*}
\]</p>
<p>In Q, it can be implemented as:</p>
<pre><code class="language-q">partedOverhead:{[u] 8*5+u+3*nextPower2 u}
</code></pre>
<p>Example:</p>
<pre><code class="language-q">q)partedOverhead 1+til 10
72 104 160 168 272 280 288 296 496 504
</code></pre>
<h3 id="grouped"><a class="header" href="#grouped">Grouped</a></h3>
<p>The overhead of the <em>grouped</em> attribute depends on both the total count of the list (<em>n</em>) and the count of unique values (<em>u</em>). Internally, KDB+ builds a hash map that stores each unique value along with the indices of all its occurrences in the list, which explains this dual dependency.</p>
<p>To measure the overhead, we tested lists of 10,000 and 20,000 elements with varying counts of unique values. For comparability, the 20,000-element list was tested only up to 10,000 unique values.</p>
<p><img src="../images/grouped_attr_overhead.png" title="Impact of List Count &amp; Unique Value Count on Grouped Attribute Overhead" alt="Impact of List Count &amp; Unique Value Count on Grouped Attribute Overhead"></p>
<p>The chart shows two lines ‚Äî one for each total list count. For a given count of unique values, the larger list incurs higher overhead, confirming that the <em>grouped</em> attribute scales with both list count and the count of unique elements.</p>
<h4 id="analysing-the-overhead"><a class="header" href="#analysing-the-overhead">Analysing the Overhead</a></h4>
<p>Let‚Äôs look at a small snippet of the results for each total list count.</p>
<p><strong>Snippet for List Count = 10,0000</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Count of Unique Values</th><th>Overhead (Bytes)</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>80,088</td></tr>
<tr><td>2</td><td>80,120</td></tr>
<tr><td>3</td><td>80,176</td></tr>
<tr><td>4</td><td>80,184</td></tr>
<tr><td>5</td><td>80,288</td></tr>
<tr><td>6</td><td>80,296</td></tr>
<tr><td>7</td><td>80,304</td></tr>
<tr><td>8</td><td>80,312</td></tr>
<tr><td>9</td><td>80,512</td></tr>
<tr><td>..</td><td>..</td></tr>
<tr><td>15</td><td>80,560</td></tr>
<tr><td>16</td><td>80,568</td></tr>
<tr><td>17</td><td>80,960</td></tr>
<tr><td>..</td><td>..</td></tr>
</tbody>
</table>
</div>
<p>At powers of 2 (1, 2, 4, 8, 16), we observe the following overheads:</p>
<pre><code>u:         1       2       4       8       16
overhead:  80,088  80,120  80,184  80,312  80,568
</code></pre>
<p>Subtracting 80,056 from these values gives:</p>
<pre><code>32, 64, 128, 256, 512 = 32 √ó (1, 2, 4, 8, 16)
</code></pre>
<p>This suggests that for power-of-2 <em>u</em>, the overhead is:</p>
<p>\[
\text{overhead} = 80,056 + 32ùëù
\]</p>
<p>We‚Äôll revisit the 80,056 in a moment.</p>
<p><strong>Snippet for List Count = 20,0000</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Count of Unique Values</th><th>Overhead (Bytes)</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>160,088</td></tr>
<tr><td>2</td><td>160,120</td></tr>
<tr><td>3</td><td>160,176</td></tr>
<tr><td>4</td><td>160,184</td></tr>
<tr><td>5</td><td>160,288</td></tr>
<tr><td>6</td><td>160,296</td></tr>
<tr><td>7</td><td>160,304</td></tr>
<tr><td>8</td><td>160,312</td></tr>
<tr><td>9</td><td>160,512</td></tr>
<tr><td>..</td><td>..</td></tr>
<tr><td>15</td><td>160,560</td></tr>
<tr><td>16</td><td>160,568</td></tr>
<tr><td>17</td><td>160,960</td></tr>
<tr><td>..</td><td>..</td></tr>
</tbody>
</table>
</div>
<p>Again, for powers of 2:</p>
<pre><code>u:        1        2        4        8        16
overhead: 160,088  160,120  160,184  160,312  160,568
</code></pre>
<p>Subtracting 160,056 yields the same \(32 √ó p\) pattern</p>
<p><strong>Interpreting the Base Overhead</strong></p>
<p>Notice that:</p>
<ul>
<li>For the 10,000-element list, the offset was 80,056</li>
<li>For the 20,000-element list, it was 160,056</li>
</ul>
<p>This suggests the base overhead grows linearly with the list count. Specifically:</p>
<p>\[
\begin{align*}
80,056 &amp;= 56 + 8 √ó 10,000 \\
160,056 &amp;= 56+8√ó20,000
\end{align*}
\]</p>
<p>So, the general base overhead is:</p>
<p>\[
base = 56 + 8n
\]</p>
<p>where <em>n</em> is the total count of the list, and 56 is likely a fixed base cost for the internal structure.</p>
<h4 id="general-formula"><a class="header" href="#general-formula">General Formula</a></h4>
<p>For non-power-of-2 u, we again see 8-byte increments per unique value until the next power-of-2 is reached. Thus, the total overhead can be expressed as:</p>
<p>\[
\begin{align*}
\text{overhead} &amp;= 56 + 8n + 32p + 8(u - p) \\
&amp;= 8(3p + n + u + 7)
\end{align*}
\]</p>
<p>Where:</p>
<ul>
<li><em>n</em> is the list count.</li>
<li><em>u</em> is the count of unique values.</li>
<li><em>p</em> is the next power of 2 greater than or equal to <em>u</em>.</li>
</ul>
<p><strong>Q Implementation</strong></p>
<pre><code class="language-q">groupedOverhead:{[n;u] 8*7+n+u+3*nextPower2 u}
</code></pre>
<p>Examples:</p>
<pre><code class="language-q">q)groupedOverhead[10000;] 1+til 10
80088 80120 80176 80184 80288 80296 80304 80312 80512 80520

q)groupedOverhead[20000;] 1+til 10
160088 160120 160176 160184 160288 160296 160304 160312 160512 160520
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>The formulas derived for computing attribute overheads are based on the current internal implementation of KDB+. As such, they may change in future versions if the underlying architecture is modified.
However, the methodology used to derive these formulas ‚Äî through systematic measurement and pattern analysis ‚Äî can still be applied to recalculate overheads if needed. The approach is general and remains valid even if the specific outcomes evolve over time.</p>
</blockquote>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>While KDB+ attributes offer powerful query optimisations, we have shown that these benefits come with measurable costs in time and memory.</p>
<p>We‚Äôve seen that attributes like <em>unique</em>, <em>parted</em>, and <em>grouped</em> maintain internal data structure ‚Äî typically hash maps ‚Äî that vary in size depending on both the total count of the list and the count of unique values. This leads to non-trivial memory overhead, which can scale into hundreds of megabytes or more for large datasets.</p>
<p>We also observed that applying attributes can incur time overhead during operations like loading, writing, or updating data ‚Äî particularly for attributes that require hashing or maintaining metadata during write time.</p>
<p>The key takeaway is that attributes are not free. Their use should be deliberate and informed. If the expected query performance improvement outweighs the storage and update costs, they can be extremely valuable. But for infrequently queried or write-heavy data, the overhead might not justify their use.</p>
<p>As always with performance tuning, measure before and after, and choose the right tool for the workload.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="performance-benefits-of-kdb-attributes"><a class="header" href="#performance-benefits-of-kdb-attributes">Performance Benefits of KDB+ Attributes</a></h1>
<p><img src="images/attr_perf_benefits.png" title="Cover Image" alt="Cover Image"></p>
<p>Attributes in KDB+ are powerful performance optimisations that can dramatically accelerate queries on large datasets. In this blog, we‚Äôll dive into the tangible performance benefits they offer‚Ää-‚Äämeasuring real-world improvements in speed and efficiency. If you‚Äôre new to attributes or want a refresher on their mechanics and use cases, check out my <a href="#kdb-attributes">previous blog post</a>  for a detailed introduction.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<ul>
<li>Results were generated using Q/KDB+ version 4.1 (2025.04.28).</li>
<li>Times are shown in milliseconds and space in megabytes.</li>
<li>Figures are shown to three significant figures.</li>
</ul>
</blockquote>
<h2 id="basic-list-operations"><a class="header" href="#basic-list-operations">Basic List Operations</a></h2>
<p>To understand the impact of attributes on performance, we begin by analysing basic list operations.</p>
<p>Each test followed this methodology:</p>
<ol>
<li>
<p>A sorted list of <em>N</em> unique elements was created using <code>til N</code>.</p>
</li>
<li>
<p>For binary operations, a random element from the list was selected as the second operand.</p>
</li>
<li>
<p>The operation was executed on the list without any attribute, then repeated with each attribute applied.</p>
</li>
<li>
<p>Steps 2‚Äì3 were repeated multiple times, and the average execution time was recorded for accuracy.</p>
</li>
</ol>
<p>In addition to the primary list type, I also tested two other structures:</p>
<ul>
<li>A unique, unsorted list generated using <code>neg[N]?N</code> (list is sorted when applying <em>sorted</em> and <em>parted</em> attributes).</li>
<li>A non-unique, unsorted list generated using <code>N?N div 4</code> (<em>unique</em> attribute excluded for this case).</li>
</ul>
<p>This allows us to determine if the underlying structure of the list affects performance trends. Unless otherwise noted, the trends were consistent across list types.</p>
<h3 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h3>
<p>KDB+ provides several standard comparison operators, familiar to users of other languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>=</code></td><td>Equal</td></tr>
<tr><td><code>&lt;&gt;</code></td><td>Not Equal</td></tr>
<tr><td><code>&lt;</code></td><td>Less Than</td></tr>
<tr><td><code>&gt;</code></td><td>Greater Than</td></tr>
<tr><td><code>&lt;=</code></td><td>Less Than or Equal</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater Than or Equal</td></tr>
</tbody>
</table>
</div>
<h4 id="how-the-sorted-attribute-boosts-performance"><a class="header" href="#how-the-sorted-attribute-boosts-performance">How the Sorted Attribute Boosts Performance</a></h4>
<p>The <em>sorted</em> attribute enables Q/KDB+ to use binary search instead of linear search, significantly improving performance on large lists. Consider the following example using the less than (<code>&lt;</code>) operator:</p>
<p>List: <code>1 2 3 4 5 6 7 8 9 10</code>, searching for <code>&lt; 7</code></p>
<pre><code>1 2 3 4 5 6 7 8 9 10
        ^              // Midpoint: 5 &lt; 7 ‚Üí Search right half
1 1 1 1 1 . . . . .

6 7 8 9 10
    ^                  // Midpoint: 8 &gt; 7 ‚Üí Search left half
. . 0 0 0

6 7
^                      // Midpoint: 6 &lt; 7 ‚Üí Search right
1 .

7
^                      // 7 = 7 ‚Üí Done
0
</code></pre>
<p>The full comparison is completed in just a few steps using binary search ‚Äî far faster than checking each element sequentially.</p>
<h4 id="equal--and-not-equal-"><a class="header" href="#equal--and-not-equal-">Equal (<code>=</code>) and Not Equal (<code>&lt;&gt;</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000408</td><td>0.000409</td><td>0.000409</td><td>0.000411</td><td>0.000407</td></tr>
<tr><td>10,000</td><td>0.00330</td><td>0.00337</td><td>0.00335</td><td>0.00333</td><td>0.00331</td></tr>
<tr><td>100,000</td><td>0.0481</td><td>0.0485</td><td>0.0477</td><td>0.0482</td><td>0.0483</td></tr>
<tr><td>1,000,000</td><td>0.649</td><td>0.634</td><td>0.680</td><td>0.603</td><td>0.640</td></tr>
<tr><td>10,000,000</td><td>7.46</td><td>7.75</td><td>7.80</td><td>7.48</td><td>7.51</td></tr>
<tr><td>100,000,000</td><td>76.0</td><td>76.3</td><td>76.3</td><td>75.2</td><td>76.4</td></tr>
</tbody>
</table>
</div>
<p>Surprisingly, the <code>=</code> and <code>&lt;&gt;</code> operators do not appear to benefit from any attribute ‚Äî even on large lists. The operation time scales roughly linearly with list count. This behaviour contrasts sharply with other comparison operators that benefit from the <em>sorted</em> attribute.</p>
<h4 id="less-than--and-greater-than-"><a class="header" href="#less-than--and-greater-than-">Less Than (<code>&lt;</code>) and Greater Than (<code>&gt;</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.00169</td><td>0.00137</td><td>0.00176</td><td>0.00166</td><td>0.00168</td></tr>
<tr><td>10,000</td><td>0.0128</td><td>0.00239</td><td>0.0126</td><td>0.0121</td><td>0.0124</td></tr>
<tr><td>100,000</td><td>0.121</td><td>0.0094</td><td>0.117</td><td>0.119</td><td>0.123</td></tr>
<tr><td>1,000,000</td><td>1.455</td><td>0.113</td><td>1.46</td><td>1.47</td><td>1.46</td></tr>
<tr><td>10,000,000</td><td>12.8</td><td>1.06</td><td>12.8</td><td>13.0</td><td>12.9</td></tr>
<tr><td>100,000,000</td><td>76.9</td><td>5.40</td><td>78.3</td><td>79.6</td><td>77.4</td></tr>
</tbody>
</table>
</div>
<p>These results clearly demonstrate the benefit of the <em>sorted</em> attribute for range-based comparisons. The performance gain becomes increasingly significant as the data volume grows, thanks to binary search.</p>
<h4 id="less-than-or-equal--and-greater-than-or-equal-"><a class="header" href="#less-than-or-equal--and-greater-than-or-equal-">Less Than Or Equal (<code>&lt;</code>=) and Greater Than Or Equal (<code>&gt;=</code>)</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000724</td><td>0.000530</td><td>0.000747</td><td>0.000712</td><td>0.000710</td></tr>
<tr><td>10,000</td><td>0.0113</td><td>0.00268</td><td>0.0113</td><td>0.0111</td><td>0.0117</td></tr>
<tr><td>100,000</td><td>0.131</td><td>0.0186</td><td>0.137</td><td>0.134</td><td>0.132</td></tr>
<tr><td>1,000,000</td><td>1.633</td><td>0.312</td><td>1.651</td><td>1.661</td><td>1.658</td></tr>
<tr><td>10,000,000</td><td>16.4</td><td>3.20</td><td>16.4</td><td>16.6</td><td>16.3</td></tr>
<tr><td>100,000,000</td><td>79.3</td><td>16.4</td><td>77.7</td><td>78.6</td><td>78.2</td></tr>
</tbody>
</table>
</div>
<p>These compound comparisons also benefit from the <em>sorted</em> attribute, although not as dramatically as their strict counterparts. This is likely because the equality portion of the operation introduces a slight overhead compared to strict inequality.</p>
<h3 id="the-find-operator-"><a class="header" href="#the-find-operator-">The Find Operator (<code>?</code>)</a></h3>
<p>The find operator (<code>?</code>) searches for an item in a list. If found, it returns the <strong>index of the first occurrence</strong>. If not found, it returns the <strong>count of the list</strong>, which is one past the last index.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000452</td><td>0.000350</td><td>0.000302</td><td>0.000318</td><td>0.000300</td></tr>
<tr><td>10,000</td><td>0.00243</td><td>0.000435</td><td>0.000331</td><td>0.000369</td><td>0.000348</td></tr>
<tr><td>100,000</td><td>0.0196</td><td>0.000361</td><td>0.000258</td><td>0.000269</td><td>0.000265</td></tr>
<tr><td>1,000,000</td><td>0.224</td><td>0.000361</td><td>0.000244</td><td>0.000279</td><td>0.000250</td></tr>
<tr><td>10,000,000</td><td>2.80</td><td>0.000339</td><td>0.000240</td><td>0.000253</td><td>0.000242</td></tr>
<tr><td>100,000,000</td><td>31.1</td><td>0.000401</td><td>0.000249</td><td>0.000256</td><td>0.000284</td></tr>
</tbody>
</table>
</div>
<p>The find operation shows dramatic performance improvements when using any of the attributes. The <em>unique</em>, <em>parted</em>, and <em>grouped</em> attributes offer nearly 2√ó better performance than <em>sorted</em> for a list with 100 million elements.</p>
<p>However, these three attributes require additional overhead to store internal structures (such as hash maps), whereas the <em>sorted</em> attribute does not require any extra space ‚Äî making it a more lightweight option when applicable.</p>
<h3 id="minimum-min-and-maximum-max"><a class="header" href="#minimum-min-and-maximum-max">Minimum (<code>min</code>) and Maximum (<code>max</code>)</a></h3>
<p>The <code>min</code> and <code>max</code> functions return the smallest and largest elements in a list, respectively.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000335</td><td>0.000102</td><td>0.000320</td><td>0.000326</td><td>0.000320</td></tr>
<tr><td>10,000</td><td>0.00203</td><td>0.0000990</td><td>0.00204</td><td>0.00204</td><td>0.00204</td></tr>
<tr><td>100,000</td><td>0.0192</td><td>0.000104</td><td>0.0192</td><td>0.0253</td><td>0.0195</td></tr>
<tr><td>1,000,000</td><td>0.431</td><td>0.000117</td><td>0.242</td><td>0.240</td><td>0.222</td></tr>
<tr><td>10,000,000</td><td>5.21</td><td>0.000109</td><td>4.57</td><td>6.04</td><td>4.71</td></tr>
<tr><td>100,000,000</td><td>55.8</td><td>0.000284</td><td>53.1</td><td>59.2</td><td>49.2</td></tr>
</tbody>
</table>
</div>
<p>When a list is <em>sorted</em>, the minimum and maximum values are simply the first and last elements. This makes these operations constant time, regardless of list count, as reflected in the table above.</p>
<p>Other attributes (<em>unique</em>, <em>parted</em>, <em>grouped</em>) do not show meaningful benefit.</p>
<h4 id="special-case-non-unique-unsorted-lists"><a class="header" href="#special-case-non-unique-unsorted-lists">Special Case: Non-Unique, Unsorted Lists</a></h4>
<p>In the case of a non-unique, unsorted list, we observed a performance gain with the <em>parted</em> attribute:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.000731</td><td>0.000259</td><td>0.000475</td><td>0.000764</td></tr>
<tr><td>10,000</td><td>0.00457</td><td>0.000262</td><td>0.00112</td><td>0.00428</td></tr>
<tr><td>100,000</td><td>0.0386</td><td>0.000275</td><td>0.0102</td><td>0.0396</td></tr>
<tr><td>1,000,000</td><td>0.937</td><td>0.000223</td><td>0.125</td><td>1.29</td></tr>
<tr><td>10,000,000</td><td>10.6</td><td>0.000281</td><td>1.64</td><td>6.61</td></tr>
<tr><td>100,000,000</td><td>57.9</td><td>0.000147</td><td>20.9</td><td>63.1</td></tr>
</tbody>
</table>
</div>
<p>This improvement likely stems from how the <em>parted</em> attribute internally manages buckets of unique values. In a non-unique list, the underlying hash map only needs to examine the keys (i.e., unique values) when computing the minimum or maximum. This subset is often much smaller than the original list, making the operation faster in practice.</p>
<h3 id="distinct-distinct"><a class="header" href="#distinct-distinct">Distinct (<code>distinct</code>)</a></h3>
<p>The <code>distinct</code> function returns a list of the unique elements from the input list, preserving their first occurrence.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Unique</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.00290</td><td>0.00370</td><td>0.000157</td><td>0.000801</td><td>0.0150</td></tr>
<tr><td>10,000</td><td>0.0321</td><td>0.0342</td><td>0.000135</td><td>0.00446</td><td>0.0997</td></tr>
<tr><td>100,000</td><td>0.439</td><td>0.542</td><td>0.000228</td><td>0.183</td><td>1.50</td></tr>
<tr><td>1,000,000</td><td>6.77</td><td>5.82</td><td>0.000209</td><td>2.24</td><td>16.5</td></tr>
<tr><td>10,000,000</td><td>50.5</td><td>40.6</td><td>0.000212</td><td>18.2</td><td>135</td></tr>
<tr><td>100,000,000</td><td>432</td><td>462</td><td>0.000207</td><td>159</td><td>1360</td></tr>
</tbody>
</table>
</div>
<p>With the <em>unique</em> attribute, the <code>distinct</code> operation becomes essentially free ‚Äî the list is already composed of unique elements, so the function simply returns the list as-is. This results in constant-time performance, regardless of the list count.</p>
<p>The <em>parted</em> attribute also provides a significant performance boost. This is because a parted list internally maintains a hash map of unique values, so distinct can efficiently return the map‚Äôs keys, bypassing a full scan of the list.</p>
<p>The <em>sorted</em> attribute, by contrast, offers no substantial benefit. While sorted lists could potentially allow for early exit strategies or linear scanning, this doesn‚Äôt appear to be leveraged in the current implementation.</p>
<p>Surprisingly, the <em>grouped</em> attribute ‚Äî despite also maintaining a hash map ‚Äî performs worse than having no attribute at all. The reason for this is unclear. It may be due to internal overheads in the way grouped lists are structured or accessed.</p>
<h4 id="special-case-non-unique-unsorted-lists-1"><a class="header" href="#special-case-non-unique-unsorted-lists-1">Special Case: Non-Unique, Unsorted Lists</a></h4>
<p>When applied to a non-unique, unsorted list, the <em>parted</em> attribute once again offers a meaningful advantage:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>List Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>1,000</td><td>0.00341</td><td>0.00237</td><td>0.000271</td><td>0.00219</td></tr>
<tr><td>10,000</td><td>0.0257</td><td>0.0347</td><td>0.000685</td><td>0.0187</td></tr>
<tr><td>100,000</td><td>0.454</td><td>0.576</td><td>0.0177</td><td>0.466</td></tr>
<tr><td>1,000,000</td><td>7.03</td><td>8.28</td><td>0.483</td><td>4.73</td></tr>
<tr><td>10,000,000</td><td>58.9</td><td>52.0</td><td>3.76</td><td>24.1</td></tr>
<tr><td>100,000,000</td><td>1330</td><td>537</td><td>34.3</td><td>347</td></tr>
</tbody>
</table>
</div>
<p>In this case, the <em>parted</em> attribute delivers a ~5√ó improvement compared to the normal case (unique, sorted list). This confirms that <em>parted</em> is particularly effective for lists with high duplication, where the internal hash structure enables fast access to the unique keys.</p>
<h2 id="disk-read-operations"><a class="header" href="#disk-read-operations">Disk Read Operations</a></h2>
<p>Up to this point, we‚Äôve explored how attributes affect in-memory lists. While useful for illustration, the more common real-world application of attributes is in on-disk (splayed) tables ‚Äî particularly to optimise disk reads, which are far more costly than memory access.</p>
<p>In this section, we evaluate a few basic queries to see how disk read performance is affected by applying attributes to specific columns.</p>
<p>For the tests, I created several splayed tables with the following schema, each containing a different number of rows:</p>
<pre><code class="language-q">// Schema
([] time:`timestamp$(); sym:`symbol$(); price:`float$(); size:`long$(); side:`char$())
</code></pre>
<h3 id="query-time--randtime"><a class="header" href="#query-time--randtime">Query: <code>time &gt; randTime</code></a></h3>
<p>In time-series data, the <em>time</em> column typically arrives in order, making it a good candidate for the <em>sorted</em> attribute. This query selects <em>sym</em> and <em>price</em> for rows where the time is greater than a randomly chosen timestamp:</p>
<pre><code class="language-q">randTime:exec rand time from table
select sym, price from table where time&gt;randTime
</code></pre>
<p>Both execution time and memory usage (space) was measured for two cases: with and without the <em>sorted</em> attribute on the time column.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute (Time)</th><th>Sorted (Time)</th><th>No Attribute (Space)</th><th>Sorted (Space)</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>36.0</td><td>26.3</td><td>0.374</td><td>0.250</td></tr>
<tr><td>1,000,000</td><td>168</td><td>88.7</td><td>12.0</td><td>8.00</td></tr>
<tr><td>10,000,000</td><td>1780</td><td>1140</td><td>192</td><td>128</td></tr>
<tr><td>100,000,000</td><td>7210</td><td>1098</td><td>384</td><td>256</td></tr>
</tbody>
</table>
</div>
<p>The <em>sorted</em> attribute yields substantial improvements in both speed and memory efficiency. This is due to the underlying binary search strategy enabled by sorted data, which minimises disk reads.</p>
<h3 id="query-time--randtime-1"><a class="header" href="#query-time--randtime-1">Query: <code>time = randTime</code></a></h3>
<p>In earlier in-memory tests, we observed that the <code>=</code> operator did not benefit from the <em>sorted</em> attribute. Here, we test whether that holds true for on-disk tables:</p>
<pre><code class="language-q">select sym, price from table where time=randTime
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute (Time)</th><th>Sorted (Time)</th><th>No Attribute (Space)</th><th>Sorted (Space)</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>13.0</td><td>16.5</td><td>0.125</td><td>0.000458</td></tr>
<tr><td>1,000,000</td><td>100</td><td>20.2</td><td>1.00</td><td>0.000458</td></tr>
<tr><td>10,000,000</td><td>560</td><td>20.8</td><td>16.0</td><td>0.000458</td></tr>
<tr><td>100,000,000</td><td>5030</td><td>18.4</td><td>128</td><td>0.000458</td></tr>
</tbody>
</table>
</div>
<p>Interestingly, when querying on-disk data, <code>=</code> benefits greatly from the <em>sorted</em> attribute ‚Äî both in speed and memory usage. This is a contrast to the in-memory case, and it highlights how Q‚Äôs columnar storage and I/O behaviour differ between memory and disk.</p>
<h3 id="query-sym--randsym"><a class="header" href="#query-sym--randsym">Query: <code>sym = randSym</code></a></h3>
<p>The <em>sym</em> column is one of the most commonly queried columns in KDB+, often representing stock tickers or instrument identifiers. Due to its high selectivity and frequent use in filters, it is a natural candidate for attribute optimisation.</p>
<p>In this test, we query for all rows where <em>sym</em> equals a randomly selected symbol:</p>
<pre><code class="language-q">randSym:exec rand sym from table
select time, side from table where sym=randSym
</code></pre>
<p>We evaluate four cases based on the attribute applied to the <em>sym</em> column: No Attribute, <em>Sorted</em>, <em>Parted</em>, and <em>Grouped</em>.</p>
<h4 id="time"><a class="header" href="#time">Time</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>21.1</td><td>16.0</td><td>15.2</td><td>28.6</td></tr>
<tr><td>1,000,000</td><td>106</td><td>22.4</td><td>24.7</td><td>19.9</td></tr>
<tr><td>10,000,000</td><td>526</td><td>17.5</td><td>16.2</td><td>15.4</td></tr>
<tr><td>100,000,000</td><td>6200</td><td>22.3</td><td>14.3</td><td>31.6</td></tr>
</tbody>
</table>
</div>
<p>All three attributes ‚Äî <em>sorted</em>, <em>parted</em>, and <em>grouped</em> ‚Äî offer significant speedups over the unoptimised case. Of these, the <em>parted</em> attribute delivers the best performance at scale. This aligns with best practices in KDB+, where the <em>sym</em> column in on-disk tables is often <em>parted</em> to optimise equality-based filters.</p>
<h4 id="space"><a class="header" href="#space">Space</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>1.13</td><td>0.000946</td><td>0.000946</td><td>0.00140</td></tr>
<tr><td>1,000,000</td><td>9.00</td><td>0.00259</td><td>0.00259</td><td>0.00452</td></tr>
<tr><td>10,000,000</td><td>144</td><td>0.0356</td><td>0.0356</td><td>0.0668</td></tr>
<tr><td>100,000,000</td><td>1150</td><td>0.282</td><td>0.282</td><td>0.532</td></tr>
</tbody>
</table>
</div>
<p>Using attributes also leads to drastic reductions in memory usage ‚Äî by orders of magnitude. Notably, <em>sorted</em> and <em>parted</em> produce identical memory footprints, suggesting similar internal mechanisms in how the filter is executed. <em>Grouped</em> shows more memory use but still vastly outperforms the baseline.</p>
<h3 id="query-max-price-by-sym"><a class="header" href="#query-max-price-by-sym">Query: <code>max price by sym</code></a></h3>
<p>A common and often costly query pattern in KDB+ involves performing aggregations by a column ‚Äî typically <em>sym</em>. These <code>select ... by ...</code> queries group data based on distinct values of a column, then apply an aggregation such as <code>max</code>, <code>min</code>, or <code>avg</code>.</p>
<p>For this test, we perform a simple aggregation: finding the maximum price for each symbol.</p>
<pre><code class="language-q">select max price by sym from table
</code></pre>
<p>We again compare performance across four attribute configurations for the <em>sym</em> column: No Attribute, <em>Sorted</em>, <em>Parted</em>, and <em>Grouped</em>.</p>
<h4 id="time-1"><a class="header" href="#time-1">Time</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>31.6</td><td>38.4</td><td>15.4</td><td>30.6</td></tr>
<tr><td>1,000,000</td><td>224</td><td>131</td><td>76.1</td><td>134</td></tr>
<tr><td>10,000,000</td><td>1130</td><td>1080</td><td>543</td><td>1130</td></tr>
<tr><td>100,000,000</td><td>12400</td><td>12300</td><td>5090</td><td>12200</td></tr>
</tbody>
</table>
</div>
<p>The <em>parted</em> attribute yields the most significant performance improvement. This is because a <em>parted</em> column is already physically grouped by its unique values, allowing the aggregation to operate directly on these pre-formed groups without needing to reorganise the data.</p>
<p>In contrast, <em>sorted</em> and <em>grouped</em> offer no meaningful performance advantage over the unoptimised case in this scenario.</p>
<h4 id="space-1"><a class="header" href="#space-1">Space</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Row Count</th><th>No Attribute</th><th>Sorted</th><th>Parted</th><th>Grouped</th></tr>
</thead>
<tbody>
<tr><td>100,000</td><td>1.13</td><td>1.06</td><td>0.313</td><td>1.13</td></tr>
<tr><td>1,000,000</td><td>8.13</td><td>8.06</td><td>0.313</td><td>8.13</td></tr>
<tr><td>10,000,000</td><td>128</td><td>128</td><td>0.313</td><td>128</td></tr>
<tr><td>100,000,000</td><td>1024</td><td>1024</td><td>0.313</td><td>1024</td></tr>
</tbody>
</table>
</div>
<p>When using the <em>parted</em> attribute, memory usage remains constant regardless of dataset size. This suggests that no additional memory is consumed during grouping ‚Äî likely because the data is already partitioned, and aggregation can proceed without intermediate allocation.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>KDB+ attributes offer a powerful way to optimise query performance by influencing how data is accessed and retrieved. As we‚Äôve seen, each attribute ‚Äî <em>sorted</em>, <em>unique</em>, <em>parted</em>, and <em>grouped</em> ‚Äî serves a specific purpose and can dramatically reduce query times when applied appropriately. Whether it‚Äôs enabling binary search through a <em>sorted</em> list, ensuring fast membership checks via <em>unique</em>, or accelerating group-based operations with <em>parted</em> and <em>grouped</em>, attributes are key to writing high-performance Q code.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="kdb-attributes"><a class="header" href="#kdb-attributes">KDB+ Attributes</a></h1>
<p><img src="images/attributes.png" title="Cover Image" alt="Cover Image"></p>
<p>KDB+ provides four attributes ‚Äî <em>sorted</em>, <em>unique</em>, <em>parted</em>, and <em>grouped</em> ‚Äî that can be applied to lists and table columns to significantly enhance query performance. However, understanding when these attributes are preserved, lost, or best applied can be subtle and often overlooked. This blog explores how these attributes behave under common operations, where they are most effectively used, and some special behaviours ‚Äî particularly of the <em>sorted</em> attribute. Whether you‚Äôre optimising an RDB or HDB, mastering attribute behaviour is key to writing efficient, high-performance KDB+ code.</p>
<h2 id="what-is-an-attribute"><a class="header" href="#what-is-an-attribute">What is an Attribute?</a></h2>
<p>In KDB+, an attribute is a form of metadata that can be applied to a list (also dictionaries and tables for <em>sorted</em>), provided the list has a structure compatible with that attribute. This metadata instructs the Q interpreter to apply certain optimisations when processing the list, potentially leading to significant performance improvements in queries and operations.</p>
<p>However, attributes come with trade-offs. Maintaining attribute integrity (<a href="#attribute-preservation">attribute preservation</a>) can add complexity to your code. Additionally, attributes can introduce performance overhead, both in terms of memory usage and execution time. For a deeper exploration of performance implications, see my other blog post <a href="#performance-costs-of-kdb-attributes">Performance Costs of KDB+ Attributes</a>.</p>
<h2 id="the-four-attributes"><a class="header" href="#the-four-attributes">The Four Attributes</a></h2>
<p>KDB+ provides four attributes that can be applied to lists to enable specific performance optimisations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Code</th><th>Required Structure</th><th>Optimisation</th></tr>
</thead>
<tbody>
<tr><td><em>Sorted</em></td><td>s</td><td>List must be sorted in ascending order.</td><td>Enables the use of binary search instead of linear search, improving search performance.</td></tr>
<tr><td><em>Unique</em></td><td>u</td><td>List must contain only unique values.</td><td>Builds a hash table that maps each unique element to its index in the list.</td></tr>
<tr><td><em>Parted</em></td><td>p</td><td>List must be sorted into contiguous blocks of identical elements.</td><td>Builds a hash table mapping each unique element to the index of the first element in its group.</td></tr>
<tr><td><em>Grouped</em></td><td>g</td><td>No structural requirement.</td><td>Builds a hash table mapping each unique element to the list of indexes where it occurs.</td></tr>
</tbody>
</table>
</div>
<h3 id="example-sorted-searching"><a class="header" href="#example-sorted-searching">Example: Sorted Searching</a></h3>
<p>To illustrate how different search algorithms operate, let‚Äôs search for (the first occurrence of) the number 7 in a sorted list of numbers from 1 to 10.</p>
<p><a href="https://en.wikipedia.org/wiki/Linear_search">Linear search</a> sequentially examines each element until a match is found (or the end of the list is reached).</p>
<pre><code>1 2 3 4 5 6 7 8 9 10
^                      // 1 ‚â† 7

1 2 3 4 5 6 7 8 9 10
^                      // 2 ‚â† 7

1 2 3 4 5 6 7 8 9 10
    ^                  // 3 ‚â† 7

1 2 3 4 5 6 7 8 9 10
    ^                  // 4 ‚â† 7

1 2 3 4 5 6 7 8 9 10
        ^              // 5 ‚â† 7

1 2 3 4 5 6 7 8 9 10
        ^              // 6 ‚â† 7

1 2 3 4 5 6 7 8 9 10
            ^          // 7 = 7 ‚Üí Found at index 6

// Result: Item found after checking 7 elements
</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Binary_search">Binary search</a> uses a divide-and-conquer approach and only works on sorted data.</p>
<pre><code>1 2 3 4 5 6 7 8 9 10
        ^              // Midpoint: 5 &lt; 7 ‚Üí Search right half

6 7 8 9 10
    ^                  // Midpoint: 8 &gt; 7 ‚Üí Search left half

6 7
^                      // Midpoint: 6 &lt; 7 ‚Üí Search right

7
^                      // 7 = 7 ‚Üí Found at index 6

// Result: Item found after checking only 4 elements
</code></pre>
<h3 id="example-unique-hash-table"><a class="header" href="#example-unique-hash-table">Example: Unique Hash Table</a></h3>
<p>The following example shows the internal hash table Q creates when the <em>unique</em> attribute is applied:</p>
<pre><code class="language-q">q)mylist:`u#`a`b`c`z`y`x

// Resulting hash table:
a | 0
b | 1
c | 2
z | 3
y | 4
x | 5
</code></pre>
<h3 id="example-parted-hash-table"><a class="header" href="#example-parted-hash-table">Example: Parted Hash Table</a></h3>
<p>Here‚Äôs what Q generates when the <em>parted</em> attribute is applied:</p>
<pre><code class="language-q">q)mylist:`p#`a`a`a`b`b`b`c`z`z`z`z`z`y`x`x

// Resulting hash table:
a | 0
b | 3
c | 6
z | 7
y | 12
x | 13
</code></pre>
<h3 id="example-grouped-hash-table"><a class="header" href="#example-grouped-hash-table">Example: Grouped Hash Table</a></h3>
<p>Finally, this example illustrates the hash table built by Q when the <em>grouped</em> attribute is used:</p>
<pre><code class="language-q">q)mylist:`g#`a`a`b`c`z`a`z`y`x`x`c`y

// Resulting hash table:
a | 0 1 5
b | 2
c | 3 10
z | 4 6
y | 7 11
x | 8 9
</code></pre>
<h2 id="attribute-operations"><a class="header" href="#attribute-operations">Attribute Operations</a></h2>
<p>There are three primary operations related to attributes in KDB+: <strong>applying</strong>, <strong>removing</strong>, and <strong>checking</strong> attributes on a list.</p>
<h3 id="applying"><a class="header" href="#applying">Applying</a></h3>
<p>Attributes are applied using the <code>#</code> operator:</p>
<pre><code class="language-q">x#y
</code></pre>
<p>Where:</p>
<ul>
<li><em>x</em> is the attribute code as a symbol (<code>`s, `u, `p, or `g</code>).</li>
<li><em>y</em> is the list to apply the attribute to.</li>
</ul>
<h4 id="object-copying"><a class="header" href="#object-copying">Object Copying</a></h4>
<p>When an attribute is applied to a list, it creates a copy of the original list with the attribute applied. We can confirm this behaviour by inspecting the reference count of the object using the internal function <code>-16!</code>, which reveals how many references point to the same memory location.</p>
<pre><code class="language-q">q)show n:til 10
0 1 2 3 4 5 6 7 8 9
q)m:n
// Both m and n point to the same object in memory
q)-16!m
2i
q)-16!n
2i
</code></pre>
<p>Now apply an attribute (e.g., <em>unique</em>) to <em>n</em>:</p>
<pre><code class="language-q">q)show n:til 10
0 1 2 3 4 5 6 7 8 9
q)show m:`u#n
`u#0 1 2 3 4 5 6 7 8 9

// m and n now reference separate objects
q)-16!n
1i
q)-16!m
1i
</code></pre>
<h4 id="exception-sorted-attribute-applied-in-place"><a class="header" href="#exception-sorted-attribute-applied-in-place">Exception: Sorted Attribute Applied In-Place</a></h4>
<p>Unlike the other attributes, the <em>sorted</em> attribute is applied in-place, i.e., it modifies the original object even without reassignment.</p>
<pre><code class="language-q">q)n:til 10
q)`s#n
`s#0 1 2 3 4 5 6 7 8 9

// Despite no reassignment, the attribute is applied to n
q)n
`s#0 1 2 3 4 5 6 7 8 9
</code></pre>
<p>This behaviour remains even when assigned to another variable:</p>
<pre><code class="language-q">q)n:til 10
q)show m:`s#n
`s#0 1 2 3 4 5 6 7 8 9
q)n
`s#0 1 2 3 4 5 6 7 8 9

// m and n reference separate objects
q)-16!n
1i
q)-16!m
1i
</code></pre>
<h4 id="other-attributes-require-reassignment"><a class="header" href="#other-attributes-require-reassignment">Other Attributes Require Reassignment</a></h4>
<p>For all other attributes (<em>unique</em>, <em>grouped</em>, <em>parted</em>), reassignment is necessary to retain the attribute:</p>
<pre><code class="language-q">q)n:til 10
q)`u#n
`u#0 1 2 3 4 5 6 7 8 9

// The attribute is not preserved unless reassigned
q)n
0 1 2 3 4 5 6 7 8 9
q)n:`u#n
q)n
`u#0 1 2 3 4 5 6 7 8 9
</code></pre>
<h4 id="list-structure-verification"><a class="header" href="#list-structure-verification">List Structure Verification</a></h4>
<p>When applying the <em>sorted</em>, <em>unique</em>, or <em>parted</em> attributes, Q verifies that the list meets the required structure. If not, an error is raised:</p>
<pre><code class="language-q">q)`s#4 2 5 1 3
's-fail
  [0]  `s#4 2 5 1 3
         ^

q)`u#1 2 1 2 1
'u-fail
  [0]  `u#1 2 1 2 1
         ^

// For `p, Q also throws a 'u-fail if the list is not properly parted
q)`p#1 2 1 2 1
'u-fail
  [0]  `p#1 2 1 2 1
         ^
</code></pre>
<p>As a convenience, applying asc to a list will automatically assign the <em>sorted</em> attribute:</p>
<pre><code class="language-q">q)show n:10?100
93 54 38 97 88 58 68 45 2 39
q)asc n
`s#2 38 39 45 54 58 68 88 93 97
</code></pre>
<h3 id="removing"><a class="header" href="#removing">Removing</a></h3>
<p>To remove an attribute, use the null symbol <code>`</code> as the left argument to the <code>#</code> operator:</p>
<pre><code class="language-q">`#y
</code></pre>
<p>Where <em>y</em> is the list from which the attribute should be removed.</p>
<pre><code class="language-q">q)show n:`u#til 10
`u#0 1 2 3 4 5 6 7 8 9
q)show n:`#n
0 1 2 3 4 5 6 7 8 9
</code></pre>
<h3 id="checking"><a class="header" href="#checking">Checking</a></h3>
<p>You can check the current attribute applied to a list using the <code>attr</code> keyword:</p>
<pre><code class="language-q">q)show n:`u#til 10
`u#0 1 2 3 4 5 6 7 8 9
q)attr n
`u
</code></pre>
<p>If no attribute is applied, the result is the null symbol <code>`</code>.</p>
<pre><code class="language-q">q)show n:til 10
0 1 2 3 4 5 6 7 8 9
q)attr n
`
</code></pre>
<h2 id="table-attributes"><a class="header" href="#table-attributes">Table Attributes</a></h2>
<p>Most operations in KDB+ involve working with tables. Attributes are most commonly applied to table columns, and the principles for applying, removing, and checking attributes are the same as for standalone lists.</p>
<h3 id="applying-1"><a class="header" href="#applying-1">Applying</a></h3>
<p>Attributes can be applied to table columns either:</p>
<ul>
<li>At the time of table creation, or</li>
<li>After the table is created, using an <code>update</code> statement or direct column assignment.</li>
</ul>
<h4 id="apply-on-creation"><a class="header" href="#apply-on-creation">Apply on creation</a></h4>
<pre><code class="language-q">// Apply the unique attribute to col1 when creating the table
q)show t:([] col1:`u#til 5; col2:`a`b`c`d`e)
col1 col2
---------
0    a
1    b
2    c
3    d
4    e
q)attr t`col1
`u
</code></pre>
<h4 id="apply-using-update"><a class="header" href="#apply-using-update">Apply using <code>update</code></a></h4>
<pre><code class="language-q">// Create table without attributes, then apply unique to col1
q)t:([] col1:til 5; col2:`a`b`c`d`e)
q)attr t`col1
`
q)update `u#col1 from `t
`t
q)attr t`col1
`u
</code></pre>
<h4 id="apply-using-column-assignment"><a class="header" href="#apply-using-column-assignment">Apply using column assignment</a></h4>
<pre><code class="language-q">// Apply attribute via direct column assignment
q)t:([] col1:til 5; col2:`a`b`c`d`e)
q)attr t`col1
`
q)t[`col1]:`u#t`col1
q)attr t`col1
`u
</code></pre>
<h3 id="removing-1"><a class="header" href="#removing-1">Removing</a></h3>
<p>Attributes can be removed from a table column using <code>`#</code> along with either an <code>update</code> statement or a column assignment.</p>
<h4 id="removing-using-update"><a class="header" href="#removing-using-update">Removing using <code>update</code></a></h4>
<pre><code class="language-q">q)t:([] col1:`u#til 5; col2:`a`b`c`d`e)
q)attr t`col1
`u
q)update `#col1 from `t
`t
q)attr t`col1
`
</code></pre>
<h4 id="removing-using-column-assignment"><a class="header" href="#removing-using-column-assignment">Removing using column assignment</a></h4>
<pre><code class="language-q">q)t:([] col1:`u#til 5; col2:`a`b`c`d`e)
q)attr t`col1
`u
q)t[`col1]:`#t`col1
q)attr t`col1
`
</code></pre>
<h3 id="checking-1"><a class="header" href="#checking-1">Checking</a></h3>
<p>You can use the <code>attr</code> keyword to inspect the attribute of an individual column:</p>
<pre><code class="language-q">q)t:([] col1:`u#til 5; col2:`a`b`c`d`e)
q)attr t`col1
`u
</code></pre>
<p>To view all column attributes at once, use the <code>meta</code> keyword. The <code>"a"</code> field in the metadata output indicates any attribute applied to each column:</p>
<pre><code class="language-q">q)meta t
c   | t f a
----| -----
col1| j   u
col2| s
</code></pre>
<h2 id="attribute-preservation"><a class="header" href="#attribute-preservation">Attribute Preservation</a></h2>
<p>Preserving an attribute on a list can be tricky ‚Äî many operations will strip an attribute, even if the structure appears unchanged. It‚Äôs important to understand which operations preserve attributes and which cause them to be lost.</p>
<h3 id="append-operations"><a class="header" href="#append-operations">Append Operations</a></h3>
<p>Append operations will <strong>preserve attributes</strong> (except <em>parted</em>) as long as the required structure is maintained.</p>
<h4 id="sorted-s-attribute"><a class="header" href="#sorted-s-attribute">Sorted (s) Attribute</a></h4>
<pre><code class="language-q">// Sorted preserved: elements appended in order
q)show n:`s#til 10
`s#0 1 2 3 4 5 6 7 8 9
q)show n,:10 11 12
`s#0 1 2 3 4 5 6 7 8 9 10 11 12

// Using upsert, sorted still preserved
q)n:`s#til 10
q)show n:n upsert 10 11 12
`s#0 1 2 3 4 5 6 7 8 9 10 11 12

// Appending unsorted data causes attribute to be lost
q)n:`s#til 10
q)show n,:12 11 10
0 1 2 3 4 5 6 7 8 9 12 11 10
</code></pre>
<p>Table append behaves the same</p>
<pre><code class="language-q">q)show t:([] col1:`s#til 5; col2:`a`b`c`d`e)
col1 col2
---------
0    a
1    b
2    c
3    d
4    e
q)meta t,:([] col1:5 6 7; col2:`x`y`z)   // Sorted preserved
c   | t f a
----| -----
col1| j   s
col2| s
q)meta t upsert flip (5 6 7;`x`y`z)      // Sorted preserved
c   | t f a
----| -----
col1| j   s
col2| s
q)meta t upsert flip (7 6 5;`x`y`z)      // Sorted lost
c   | t f a
----| -----
col1| j
col2| s
</code></pre>
<h4 id="unique-u-attribute"><a class="header" href="#unique-u-attribute">Unique (u) Attribute</a></h4>
<pre><code class="language-q">// Unique preserved: no duplicates added
q)show n:`u#til 10
`u#0 1 2 3 4 5 6 7 8 9
q)show n,:10 11 12
`u#0 1 2 3 4 5 6 7 8 9 10 11 12

// Unique lost: duplicates introduced
q)n:`u#til 10
q)show n,:7 8 9
0 1 2 3 4 5 6 7 8 9 7 8 9
</code></pre>
<h4 id="grouped-g-attribute"><a class="header" href="#grouped-g-attribute">Grouped (g) Attribute</a></h4>
<pre><code class="language-q">// Grouped is always preserved when appending
q)show n:`g#til 10
`g#0 1 2 3 4 5 6 7 8 9
q)show n,:til 10
`g#0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre>
<h3 id="comma-join--operation"><a class="header" href="#comma-join--operation">Comma Join (,) Operation</a></h3>
<p>A standard comma join (without assignment) creates a new list, losing any attribute.</p>
<pre><code class="language-q">q)show n:`s#til 10
`s#0 1 2 3 4 5 6 7 8 9
q)show n:n,10 11 12
0 1 2 3 4 5 6 7 8 9 10 11 12

// Even grouped is lost
q)show n:`g#til 10
`g#0 1 2 3 4 5 6 7 8 9
q)show n:n,10 11 12
0 1 2 3 4 5 6 7 8 9 10 11 12

// Tables also lose attributes on comma join
q)meta t:([] col1:`s#til 5; col2:`a`b`c`d`e)
c   | t f a
----| -----
col1| j   s
col2| s
q)meta t,([] col1:5 6 7; col2:`x`y`z)
c   | t f a
----| -----
col1| j
col2| s
</code></pre>
<h3 id="parted-p-attribute-and-append"><a class="header" href="#parted-p-attribute-and-append">Parted (p) Attribute and Append</a></h3>
<p>The <em>parted</em> attribute is only preserved when:</p>
<ul>
<li>Both lists are parted.</li>
<li>Their group values are disjoint (except in a <a href="#special-case-shared-edge-group">special case</a>).</li>
</ul>
<pre><code class="language-q">// Valid parted append: disjoint values, both parted
q)x:`p#1 1 1 2 2 3 4 4 4 4
q)y:`p#5 6 7 7
q)show z:x,y
`p#1 1 1 2 2 3 4 4 4 4 5 6 7 7

// Comma assign does not preserve parted
q)show x,:y
1 1 1 2 2 3 4 4 4 4 5 6 7 7

// y not parted ‚Üí attribute lost
q)x:`p#1 1 1 2 2 3 4 4 4 4
q)y:5 6 7 7
q)show z:x,y
1 1 1 2 2 3 4 4 4 4 5 6 7 7

// Not disjoint ‚Üí attribute lost
q)x:`p#1 1 1 2 2 3 4 4 4 4
q)y:`p#1 1 2
q)show z:x,y
1 1 1 2 2 3 4 4 4 4 1 1 2
</code></pre>
<h4 id="special-case-shared-edge-group"><a class="header" href="#special-case-shared-edge-group">Special Case: Shared edge group</a></h4>
<p>If the last group in <em>x</em> is the same as the first group in <em>y</em>, and all other groups are disjoint, the attribute is preserved.</p>
<pre><code class="language-q">// Special case: last of x = first of y
q)x:`p#1 1 1 2 2 3 4 4 4 4
q)y:`p#4 4 5 5 6
q)show z:x,y
`p#1 1 1 2 2 3 4 4 4 4 4 4 5 5 6

// Not valid: disjoint condition violated
q)x:`p#1 1 1 2 2 3 4 4 4 4
q)y:`p#6 5 5 4 4
q)show z:x,y
1 1 1 2 2 3 4 4 4 4 6 5 5 4 4
</code></pre>
<h3 id="modification-operations"><a class="header" href="#modification-operations">Modification Operations</a></h3>
<p>Any operation that modifies elements in a list (e.g., addition, replacement, deletion) results in a new list with no attribute.</p>
<pre><code class="language-q">q)show n:`s#til 10
`s#0 1 2 3 4 5 6 7 8 9

// Sorted lost
q)show m:n+1
1 2 3 4 5 6 7 8 9 10

// Even assigning back to n loses the attribute
q)show n+:1
1 2 3 4 5 6 7 8 9 10

// Replacement loses attribute
q)n:`s#5 10 15 20 25
q)n[2]:16
q)n
5 10 16 20 25

// Deletion loses attribute
q)n:`s#til 10
q)show n:-1_n
0 1 2 3 4 5 6 7 8

// Same behaviour applies to unique, parted, grouped
q)n:`u#til 10; show n+:1
q)n:`p#til 10; show n+:1
q)n:`g#til 10; show n+:1
</code></pre>
<h4 id="table-modifications"><a class="header" href="#table-modifications">Table Modifications</a></h4>
<p>Updating a table also removes column attributes:</p>
<pre><code class="language-q">q)meta t:([] col1:`s#til 5; col2:`a`b`c`d`e)
c   | t f a
----| -----
col1| j   s
col2| s
q)meta update col1+1 from t
c   | t f a
----| -----
col1| j
col2| s
</code></pre>
<h2 id="when-and-where-to-use-attributes"><a class="header" href="#when-and-where-to-use-attributes">When and Where to Use Attributes</a></h2>
<p>Attributes are most commonly applied to table columns that are frequently queried. Choosing the right attribute depends on both:</p>
<ul>
<li>The structure of the data in the column (since attributes, except <em>grouped</em>, require specific ordering or uniqueness), and</li>
<li>The cost and complexity of preserving that attribute across updates or transformations.</li>
</ul>
<p>The table below summarises typical use cases for each attribute in KDB+:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Where to Apply</th></tr>
</thead>
<tbody>
<tr><td><em>Sorted</em></td><td>On temporal columns (e.g., timestamps) where values naturally arrive in ascending order.</td></tr>
<tr><td><em>Unique</em></td><td>On columns containing unique identifiers or primary keys.</td></tr>
<tr><td><em>Parted</em></td><td>On symbol columns in a historical database (HDB) where values are fixed after initial writedown (e.g., <code>sym</code> in tick data).</td></tr>
<tr><td><em>Grouped</em></td><td>On frequently queried columns whose values are often repeated but lack a predictable structure (common in RDBs).</td></tr>
</tbody>
</table>
</div>
<p>Attribute application should be based on your specific workload and data patterns. While attributes can offer substantial performance improvements, they come with maintenance trade-offs. Always test attribute use in your environment to verify their effectiveness before applying them broadly.</p>
<h2 id="attribute-interaction-in-queries"><a class="header" href="#attribute-interaction-in-queries">Attribute Interaction in Queries</a></h2>
<p>Only the first column with an attribute referenced in a where clause benefits from the attribute. Subsequent filters operate on a derived sub-table, where attributes are no longer available.</p>
<pre><code class="language-q">q)meta t:([] col1:`s#til 5; col2:`u#`a`b`c`d`e)
c   | t f a
----| -----
col1| j   s
col2| s   u
// Only 'col1&gt;2' benefits from an attribute
q)select from t where col1&gt;2, col2 in `d`e
col1 col2
---------
3    d
4    e
</code></pre>
<p>In this example:</p>
<ul>
<li><code>col1&gt;2</code> benefits from the <em>sorted</em> attribute for efficient filtering.</li>
<li><code>col2 in `d`e</code> does not leverage the <em>unique</em> attribute, since it‚Äôs applied on a sub-table.</li>
</ul>
<h2 id="special-applications-of-sorted"><a class="header" href="#special-applications-of-sorted">Special Applications of Sorted</a></h2>
<p>The <em>sorted</em> attribute is unique among KDB+ attributes because it can be applied not only to lists (like all attributes) but also directly to dictionaries, tables, and keyed tables.</p>
<h3 id="step-functions"><a class="header" href="#step-functions">Step Functions</a></h3>
<p>Applying the <em>sorted</em> attribute to a dictionary transforms it into a step function. In this context, KDB+ will return the value associated with the largest key less than or equal to the query value:</p>
<pre><code class="language-q">q)show d:`s#10 20 30 40 50!`a`b`c`d`e
10| a
20| b
30| c
40| d
50| e
q)attr d
`s
// Attribute is visible on the key
q)key d
`s#10 20 30 40 50

q)d 10
`a
q)d 19
`a
q)d 20
`b
q)d 10000
`e

// Null since no key &lt;= 5
q)d 5
`
</code></pre>
<p>Note that the key of the dictionary must be in sorted order:</p>
<pre><code class="language-q">q)`s#20 10 30 40 50!`a`b`c`d`e
's-fail
  [0]  `s#20 10 30 40 50!`a`b`c`d`e
         ^
</code></pre>
<p>A step function behaves similarly to the <code>bin</code> keyword, except it returns an index rather than a key:</p>
<pre><code class="language-q">q)10 20 30 40 50 bin 10
0
q)10 20 30 40 50 bin 19
0
q)10 20 30 40 50 bin 20
1
q)10 20 30 40 50 bin 10000
4
// -1 since no value &lt;= 5
q)10 20 30 40 50 bin 5
-1
</code></pre>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<ul>
<li>The <em>sorted</em> attribute must be applied to the entire dictionary.</li>
<li>Applying it to just the key list does not create a step function:</li>
</ul>
<pre><code class="language-q">// Not a step function ‚Äì just a dictionary with a sorted key
q)d:(`s#10 20 30 40 50)!`a`b`c`d`e
q)attr d
`
q)attr key d
`s
q)d 19
`
</code></pre>
</blockquote>
<h3 id="tables-and-keyed-tables"><a class="header" href="#tables-and-keyed-tables">Tables and Keyed Tables</a></h3>
<p>The behaviour of the <em>sorted</em> attribute differs depending on whether it‚Äôs applied to a simple table or a keyed table:</p>
<h4 id="simple-tables"><a class="header" href="#simple-tables">Simple Tables</a></h4>
<p>When <em>sorted</em> is applied to a non-keyed (simple) table, it implicitly applies the <em>parted</em> attribute to the first column only:</p>
<pre><code class="language-q">q)meta t:([] col1:til 5; col2:`a`b`c`d`e)
c   | t f a
----| -----
col1| j
col2| s
q)meta `s#t
c   | t f a
----| -----
col1| j   p
col2| s
</code></pre>
<h4 id="keyed-tables"><a class="header" href="#keyed-tables">Keyed Tables</a></h4>
<p>For keyed tables:</p>
<ul>
<li>If there is only one key column, <em>sorted</em> is applied directly to that key column.</li>
<li>If there are multiple key columns, only the first receives the <em>parted</em> attribute.</li>
</ul>
<pre><code class="language-q">// Single-keyed table: sorted applies to the key column
q)meta t:([col1:til 5] col2:`a`b`c`d`e)
c   | t f a
----| -----
col1| j
col2| s
q)meta `s#t
c   | t f a
----| -----
col1| j   s
col2| s

// Multi-keyed table: parted applied to the first key only
q)meta t:([col1:til 5;col2:`a`b`c`d`e;col3:"abcde"] col4:1 2 3 4 5f)
c   | t f a
----| -----
col1| j
col2| s
col3| c
col4| f
q)meta `s#t
c   | t f a
----| -----
col1| j   p
col2| s
col3| c
col4| f
</code></pre>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Understanding where and how to apply attributes in KDB+ is essential for optimising query performance, especially when working with large datasets. Each attribute ‚Äî <em>sorted</em>, <em>unique</em>, <em>parted</em>, and <em>grouped</em> ‚Äî has specific use cases and constraints based on the structure of your data. While this blog focused on where attributes are most effectively applied and the special behaviour of the <em>sorted</em> attribute across different structures, it‚Äôs important to test and benchmark attribute usage in your specific environment for best results.</p>
<p>For an in-depth look at the performance impact of these attributes, including benchmarks and practical query comparisons, please refer to my follow-up blog on <a href="#performance-benefits-of-kdb-attributes">Performance Benefits of KDB+ Attributes</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="floating-point-datatypes-in-qkdb"><a class="header" href="#floating-point-datatypes-in-qkdb">Floating-Point Datatypes in Q/KDB+</a></h1>
<p><img src="images/floating_point.png" title="Cover Image" alt="Cover Image"></p>
<p>Floating-point numbers are essential for representing real-world values that require fractional precision. These numbers are used to model quantities such as measurements, scientific data, financial calculations, and approximations of irrational numbers like \(\pi\). Unlike integers, which represent whole numbers, floating-point numbers allow for the representation of both very small and very large numbers by using a decimal point and an exponent.</p>
<p>In Q/KDB+, floating-point numbers are implemented using two primary datatypes, each suited for different levels of precision. These datatypes are built on the IEEE 754 standard, which defines formats for representing floating-point numbers in a binary system. Understanding how floating-point numbers work in Q/KDB+ is critical for efficiently handling numerical data, particularly in high-performance time series and financial applications where precision and performance are crucial.</p>
<p>This blog will explore how floating-point numbers behave in Q/KDB+, including their characteristics, default types, and practical considerations such as comparison tolerance and the implications of rounding errors.</p>
<h2 id="floating-point-datatypes-in-qkdb-1"><a class="header" href="#floating-point-datatypes-in-qkdb-1">Floating-Point Datatypes in Q/KDB+</a></h2>
<p>Q/KDB+ provides two primary floating-point datatypes:</p>
<ul>
<li>
<p><code>real</code>: A 4-byte (32-bit) single-precision floating-point number, adhering to the <em>IEEE 754</em> standard. This type can hold approximately 6 decimal digits of precision.</p>
</li>
<li>
<p><code>float</code>: An 8-byte (64-bit) double-precision floating-point number, also based on the <em>IEEE 754</em> standard. This type supports approximately 15 decimal digits of precision.</p>
</li>
</ul>
<p>The table below provides a concise overview of the properties of <code>real</code> and <code>float</code> datatypes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Internal Code</th><th>Character</th><th>Size (bytes)</th><th>Example</th><th>Null</th><th>Infinity</th><th>Approx. Range</th></tr>
</thead>
<tbody>
<tr><td>real</td><td><code>8</code></td><td><code>e</code></td><td><code>4</code></td><td><code>17.5e</code></td><td><code>0Ne</code> <br /> <code>0ne</code></td><td><code>0We</code> <br /> <code>0we</code></td><td>\([-3.403 \times 10^{38}, 3.403 \times 10^{38}]\)</td></tr>
<tr><td>float</td><td><code>9</code></td><td><code>f</code></td><td><code>8</code></td><td><code>17.5f</code> <br /> <code>17.5</code></td><td><code>0Nf</code> <br /> <code>0nf</code> <br /> <code>0n</code></td><td><code>0Wf</code> <br /> <code>0wf</code> <br /> <code>0w</code></td><td>\([-1.798 \times 10^{308}, 1.798 \times 10^{308}]\)</td></tr>
</tbody>
</table>
</div>
<h2 id="default-floating-point-datatype"><a class="header" href="#default-floating-point-datatype">Default Floating-Point Datatype</a></h2>
<p>In Q/KDB+, the default floating-point type is the <code>float</code>. Any number with a decimal point and without a type character suffix will automatically be a float.</p>
<p>To explicitly define a <code>real</code>, the value must include the <code>e</code> suffix. Here are some examples:</p>
<pre><code class="language-q">7.5e // Real
7.5f // Float
7.5  // Float
.1   // Float
1.   // Float  
2e3  // Float (Scientific notation)
2e3e // Real (Scientific notation)
</code></pre>
<h3 id="note-on-scientific-notation"><a class="header" href="#note-on-scientific-notation">Note on Scientific Notation</a></h3>
<p>Scientific notation is a compact way of expressing numbers using powers of 10. Examples include <code>1.23e5</code> for \(1.23 \times 10^5\). For more details, see the <a href="#scientific-notation">Scientific Notation</a> section.</p>
<h2 id="infinities-and-nulls"><a class="header" href="#infinities-and-nulls">Infinities and Nulls</a></h2>
<p>Floating-point operations involving infinity or null values behave as expected in Q/KDB+, without wrapping like integers. For example:</p>
<pre><code class="language-q">q)10+0we
0we
q)10+0w
0w
q)-10+0we
0we
q)-10+0w
0w
</code></pre>
<p>Division by zero produces positive or negative infinity:</p>
<pre><code class="language-q">q)123%0
0w
q)-123%0
-0w
</code></pre>
<p>Dividing zero by zero produces a null <code>float</code>:</p>
<pre><code class="language-q">q)0%0
0n
</code></pre>
<h2 id="scientific-notation"><a class="header" href="#scientific-notation">Scientific Notation</a></h2>
<p>Floating-point numbers in Q can be expressed using scientific notation, where <code>e</code> indicates the exponent:</p>
<pre><code class="language-q">q)1.234e05
123400f
q)1.234e+5
123400f
q)1.234e5
123400f
q)1.234e-3
0.001234
</code></pre>
<p>To the right of the <code>e</code> is a signed exponent. The <code>+</code> and leading <code>0</code> for a positive exponent are optional.</p>
<p>To explicitly define a real in scientific notation, the <code>e</code> type suffix must be included:</p>
<pre><code class="language-q">q)1.234e3e
1234e
</code></pre>
<h2 id="display-precision-and-formatting"><a class="header" href="#display-precision-and-formatting">Display Precision and Formatting</a></h2>
<p>The Q console defaults to displaying up to 7 significant digits for floating-point values, even though the actual stored precision may be higher. You can adjust the display precision using the <code>\P</code> system command:</p>
<pre><code class="language-q">q)\P 2
q)3.14159265358979323
3.1

q)\P 10
q)3.14159265358979323
3.141592654

q)\P 0  // Full precision (17 digits for floats - the last digit is unreliable)
q)3.14159265358979323
3.1415926535897931
</code></pre>
<h2 id="comparison-tolerance"><a class="header" href="#comparison-tolerance">Comparison Tolerance</a></h2>
<p>Floating-point comparisons in Q use a tolerance mechanism to account for precision limitations. This ensures that two values close to each other are considered equal:</p>
<pre><code class="language-q">q)sum 7#1%7
0.99999999999999978

q)1f=sum 7#1%7
1b
q)1f&gt;sum 7#1%7
0b
q)1f&lt;sum 7#1%7
0b
</code></pre>
<p>However, only zero is tolerantly the same as zero:</p>
<pre><code class="language-q">q)0=1e-300
0b
q)0=0
1b
</code></pre>
<p>Therefore, for intolerant comparison, one can check if</p>
<p>\[
0 = x - y
\]</p>
<pre><code class="language-q">q)1f=sum 7#1%7
1b
q)0=1f-sum 7#1%7
0b
</code></pre>
<h3 id="built-in-comparison-tolerance"><a class="header" href="#built-in-comparison-tolerance">Built-in Comparison Tolerance</a></h3>
<p>Comparison tolerance is automatically applied in the following cases:</p>
<ul>
<li>Operators: <code>=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&gt;</code> <code>~</code></li>
<li>Keywords: <code>differ</code> <code>within</code></li>
<li>Iterators: Converge, Do, and While</li>
</ul>
<p>However, comparison tolerance is not used in:</p>
<ul>
<li>Operators: <code>?</code></li>
<li>Keywords: <code>distinct</code> <code>except</code> <code>group</code> <code>in</code> <code>inter</code> <code>union</code> <code>xgroup</code> <code>asc</code> <code>desc</code> <code>iasc</code> <code>idesc</code> <code>rank</code> <code>xasc</code> <code>xdesc</code></li>
</ul>
<h3 id="transitivity-caveat"><a class="header" href="#transitivity-caveat">Transitivity Caveat</a></h3>
<pre><code class="language-q">q)a:96.099999999999994
q)b:96.10000000001
q)c:96.10000000002

q)a=b
1b
q)b=c
1b
q)a=c
0b
</code></pre>
<p>Because of this, floats are unsuitable for use as database keys or in operations that rely on strict equality.</p>
<h3 id="formal-definition-of-tolerance"><a class="header" href="#formal-definition-of-tolerance">Formal Definition of Tolerance</a></h3>
<p>The comparison tolerance <em>T</em> in Q/KDB+ is defined as:</p>
<p>\[
T = 2^{-43} \approx 1.14 \times 10^{-13}
\]</p>
<p>This tolerance ensures that floating-point comparisons account for small relative differences between values.</p>
<p>Two floating-point values <em>x</em> and <em>y</em> are considered equal if:</p>
<p>\[
| x - y | \le T \times max(|x|, |y|)
\]</p>
<h4 id="why-non-zero-values-cannot-equal-zero"><a class="header" href="#why-non-zero-values-cannot-equal-zero">Why Non-Zero Values Cannot Equal Zero</a></h4>
<p>Under this definition, no non-zero value can be considered equal to zero. Here‚Äôs the proof:</p>
<p>\[
\begin{align*}
| x - 0 | &amp;\gt T \times max(|x|, |0|) \\
|x|       &amp;\gt T \times |x| \\
1         &amp;\gt T
\end{align*} \qquad \forall \space x \ne 0<br>\]</p>
<p>Since <em>T</em> is a very small positive constant, the inequality \(1 &gt; T\) always holds, making the condition true for all non-zero values of <em>x</em>.</p>
<h2 id="additional-notes"><a class="header" href="#additional-notes">Additional Notes</a></h2>
<h3 id="floating-point-addition-is-not-associative"><a class="header" href="#floating-point-addition-is-not-associative">Floating-Point Addition is Not Associative</a></h3>
<p>Due to rounding errors, the order of operations can affect the result of summing floating-point values:</p>
<pre><code class="language-q">q)\P 0
q)x:1e-10*til 10000000
q)sum x
4999.9995000000017
q)sum reverse x
4999.9994999999999
q){x+y} over x
4999.9994999999635
q){x+y} over reverse x
4999.9995000000026
q)sum sum 2 cut x
4999.9995000000199
</code></pre>
<h3 id="datetime-comparisons"><a class="header" href="#datetime-comparisons">Datetime Comparisons</a></h3>
<p><code>datetime</code> values in Q/KDB+ are stored as <code>float</code> and therefore use tolerance in comparisons:</p>
<pre><code class="language-q">q)a:2000.01.02+sum 1000#1%86400
q)b:2000.01.02T00:16:40.000

q)a=b   // Tolerantly equal
1b
q)0=a-b // Strict comparison
0b
</code></pre>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Floating-point numbers are a fundamental part of numerical computing, enabling the representation of continuous and approximate values in Q/KDB+. By understanding the two main floating-point types ‚Äî <code>real</code> and <code>float</code> ‚Äî along with their behaviour in operations, we can make more informed decisions about precision and performance in our applications.</p>
<p>While Q/KDB+ handles floating-point numbers with built-in comparison tolerance to mitigate small precision errors, it‚Äôs important to be mindful of the limitations, especially when working with large datasets or performing operations that require strict equality. Whether you‚Äôre using floating-point values in time series analysis, financial computations, or scientific modeling, a solid grasp of how these datatypes work will help ensure that your results are both accurate and efficient.</p>
<p>As always, when dealing with floating-point numbers, it‚Äôs essential to choose the appropriate type based on the required precision, and to be aware of potential pitfalls like non-transitive comparisons and rounding errors. By keeping these considerations in mind, you can avoid subtle bugs and make the most of Q/KDB+‚Äôs powerful numerical capabilities.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="measuring-compression-performance-in-qkdb"><a class="header" href="#measuring-compression-performance-in-qkdb">Measuring Compression Performance in Q/KDB+</a></h1>
<p><img src="images/compression_perf.png" title="Cover Image" alt="Cover Image"></p>
<p>Compression performance in Q/KDB+ is influenced by several critical factors, including the choice of compression parameters ‚Äî logical block size (LBS), compression algorithm, and algorithm level. These parameters significantly impact the compression factor (how effectively data is compressed) and influence the speed of reading and writing compressed data. Since these parameters are user-configurable, selecting the optimal combination for a specific use case is essential.</p>
<p>Equally important is the nature of the data being compressed. Characteristics such as data type, structure, and repetitiveness can heavily influence compression performance.</p>
<p>In this blog, we‚Äôll explore strategies for evaluating compression performance in Q/KDB+ and discuss how to identify the parameter configurations best suited to your data and requirements. If you‚Äôre new to compression in Q/KDB+, I recommend starting with my earlier post, <a href="#an-introduction-to-compression-in-qkdb">An Introduction to Compression in Q/KDB+</a>, where I cover the basics of compression methods and their usage. Understanding those fundamentals will provide helpful context for the experiments and analyses discussed here.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>To evaluate compression performance in Q/KDB+, I created a standalone tool available in the <a href="https://github.com/jkane17/qtools">QTools repository</a>. The specific script for measuring compression performance can be found <a href="https://github.com/jkane17/qtools/blob/main/src/zipPerf.q">here</a>. Simply copy or download this script to use it, and refer to the <a href="https://github.com/jkane17/qtools/blob/main/docs/zipPerf.md">documentation</a> for detailed instructions on the tool‚Äôs functions.</p>
<p>I have included all the code used to generate the results, so you can see examples of how this tool is used throughout this blog.</p>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<ul>
<li>All times (write and read) are reported in milliseconds.</li>
<li>Q/KDB+ version used: 4.1 (2024.05.31)</li>
</ul>
</blockquote>
<blockquote class="blockquote-tag blockquote-tag-important">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p>
<p>The results of these tests can vary based on factors such as machine architecture, the specific random values used, and other environmental conditions. The results in this blog are illustrative and intended to guide you in conducting your own performance evaluations.</p>
</blockquote>
<h2 id="savingloading-results"><a class="header" href="#savingloading-results">Saving/Loading Results</a></h2>
<p>Running some of these tests can be time-consuming. To avoid losing your results and allow for future analysis, you can save them to disk and reload them later. The following functions facilitate saving and loading data:</p>
<pre><code class="language-q">dataDir:`:/&lt;DATA-PATH&gt;/data;

// Save data
sd:{.Q.dd[x;` sv y,`csv] 0: "," 0: value y}[dataDir;];

// Load data
ld:{y set ("jjjhjfffn";enlist ",") 0: .Q.dd[x;` sv y,`csv]}[dataDir;];
</code></pre>
<p>Simply set the <code>dataDir</code> variable to the desired directory for saving the results. Once set, you can save and load the <code>results</code> table as shown below:</p>
<pre><code class="language-q">// Save the results table
q)sd `results

// Load the results table
q)ld `results
</code></pre>
<h2 id="static-data"><a class="header" href="#static-data">Static Data</a></h2>
<p>Historic data is static and unlikely to change. For such data, we can optimise compression by testing different parameter configurations and selecting the best fit for our requirements.</p>
<h3 id="example-dataset"><a class="header" href="#example-dataset">Example Dataset</a></h3>
<p>Consider a simple example: a list of 10,000 randomly generated long integers ranging from 0 to 999.</p>
<pre><code class="language-q">data:10000?1000
</code></pre>
<p>Although generated randomly, this dataset is now static. Using the <em>zipPerf</em> tool introduced in the <a href="#setup">setup</a>, we can evaluate various compression parameters to understand their impact on performance.</p>
<h3 id="testing-compression-parameters"><a class="header" href="#testing-compression-parameters">Testing Compression Parameters</a></h3>
<p>First, load the performance measurement tool and run the test:</p>
<pre><code class="language-q">q)\l &lt;PATH&gt;/qtools/src/zipPerf.q

// Run the test - Takes approx. 4 minutes (%1e6 converts timespan to milliseconds)
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAll data
</code></pre>
<h3 id="performance-metric-statistics"><a class="header" href="#performance-metric-statistics">Performance Metric Statistics</a></h3>
<p>Key performance statistics for compression factor, write time, and read time can be summarised with the following query:</p>
<pre><code class="language-q">select 
    metric:`compFactor`writeTime`readTime,
    maximum:(max compFactor; max writeTime; max readTime),
    minimum:(min compFactor; min writeTime; min readTime),
    average:(avg compFactor; avg writeTime; avg readTime)
    from results 
</code></pre>
<p>Example output:</p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 4.957621 0.9974073 3.649513 
writeTime  170.298  0.188266  12.57895 
readTime   2.733323 0.060592  0.7867975
</code></pre>
<p>This analysis reveals the range and average values for each metric. To determine the best compression configuration, let‚Äôs examine each metric individually.</p>
<h3 id="compression-factor"><a class="header" href="#compression-factor">Compression Factor</a></h3>
<p>The compression factor measures space savings, with higher values indicating more efficient compression. We identify the configuration yielding the highest compression factor:</p>
<pre><code class="language-q">q)select compFactor, lbs, alg, lvl from results where compFactor=max compFactor
compFactor lbs alg lvl
----------------------
4.957621   17  5   1  
4.957621   17  5   2  
4.957621   18  5   1  
4.957621   18  5   2  
4.957621   19  5   1  
4.957621   19  5   2  
4.957621   20  5   1  
4.957621   20  5   2
</code></pre>
<p>The highest compression factor (4.957621) is achieved with the <em>zstd</em> algorithm at level 1 or 2 and LBS values between 17 and 20.</p>
<h3 id="write-time"><a class="header" href="#write-time">Write Time</a></h3>
<p>Write time measures how quickly data is compressed and written to disk. Lower values are preferable:</p>
<pre><code class="language-q">q)select writeTime, lbs, alg, lvl from results where writeTime=min writeTime
writeTime lbs alg lvl
---------------------
0.188266  13  2   0  
</code></pre>
<p>The fastest write time (0.188266 ms) is achieved using the <em>gzip</em> algorithm at level 0 with an LBS of 13.</p>
<h3 id="read-time"><a class="header" href="#read-time">Read Time</a></h3>
<p>Read time measures how quickly compressed data can be retrieved and decompressed. Again, lower values are better:</p>
<pre><code class="language-q">q)select readTime, lbs, alg, lvl from results where readTime=min readTime
readTime lbs alg lvl
--------------------
0.060592 12  5   10
</code></pre>
<p>The fastest read time (0.060592 ms) is achieved using the <em>zstd</em> algorithm at level 10 with an LBS of 12.</p>
<h3 id="choosing-the-best-configuration"><a class="header" href="#choosing-the-best-configuration">Choosing the Best Configuration</a></h3>
<p>The ideal compression configuration depends on specific requirements:</p>
<ul>
<li><strong>Maximising Compression Factor</strong>: Suitable when storage is limited.</li>
<li><strong>Minimising Write Time</strong>: Ideal for scenarios with time-sensitive writes.</li>
<li><strong>Minimising Read Time</strong>: Common in read-heavy environments, such as historical databases.</li>
</ul>
<p><strong>Balancing Metrics</strong></p>
<p>In practice, trade-offs between metrics are often necessary. Suppose we prioritise a quick write time (&lt;0.3 ms) while maintaining a compression factor &gt;2. We can refine our query:</p>
<pre><code class="language-q">q)`writeTime xasc select compFactor, writeTime, lbs, alg, lvl from results where writeTime&lt;0.3, compFactor&gt;2
compFactor writeTime lbs alg lvl
--------------------------------
2.67451    0.263748  17  3   0  
2.469249   0.264199  14  3   0  
2.4869     0.268497  19  1   0  
2.368178   0.274438  13  1   0  
</code></pre>
<p>This query identifies configurations that balance write time and compression efficiency. The final choice should align with operational priorities and system constraints.</p>
<h2 id="generalised-compression-testing-with-random-data"><a class="header" href="#generalised-compression-testing-with-random-data">Generalised Compression Testing with Random Data</a></h2>
<p>While historic data in KDB+ is typically static, it‚Äôs often impractical to test compression across all columns, tables, and partitions due to the sheer volume of data. Instead, we can simulate different data scenarios by generating random datasets and testing compression on them.</p>
<p>This approach allows us to evaluate compression performance across a variety of data organisations, providing insights into the parameters that yield ‚Äúgood‚Äù performance in the general case.</p>
<h3 id="the-tool"><a class="header" href="#the-tool">The Tool</a></h3>
<p>The <em>zipPerf</em> tool includes the function <code>.zipPerf.testAllRand</code> for this purpose. This function takes two arguments:</p>
<ul>
<li><strong>Number of Lists</strong>: The number of random datasets to generate and test.</li>
<li><strong>Data Generator Function</strong>: A function to generate random datasets.</li>
</ul>
<p>For example, the following call generates 10 random lists, each containing 10,000 longs between 0 and 999, and evaluates compression performance for each list:</p>
<pre><code class="language-q">.zipPerf.testAllRand[10;{10000?1000}]
</code></pre>
<p>The results are aggregated, computing the average performance metrics for each parameter configuration.</p>
<h3 id="running-the-test"><a class="header" href="#running-the-test">Running the Test</a></h3>
<p>To demonstrate, let‚Äôs run the test and convert the time metrics to milliseconds:</p>
<pre><code class="language-q">// Run the test - Takes approx. 30 minutes
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{10000?1000}];
</code></pre>
<p>Using the same queries from the <a href="#static-data">Static Data</a> section, we summarise the key statistics from the results:</p>
<pre><code class="language-q">// Key performance statistics
metric     maximum  minimum   average  
---------------------------------------
compFactor 4.954066 0.9974073 3.649914 
writeTime  60.00062 0.1174    9.881192 
readTime   1.236025 0.328472  0.6572004

// Maximum compression factor
compFactor lbs alg lvl
----------------------
4.954066   17  5   1  
4.954066   18  5   1  
4.954066   19  5   1  
4.954066   20  5   1 

// Minimum write time
writeTime lbs alg lvl
---------------------
0.1174    0   0   0

// Minimum read time
readTime lbs alg lvl
--------------------
0.328472 0   0   0 
</code></pre>
<h3 id="observations"><a class="header" href="#observations">Observations</a></h3>
<ul>
<li>
<p><strong>Compression Factor</strong>: The best compression factor (4.954066) is achieved using the <em>zstd</em> algorithm at level 1, with any LBS between 17 and 20.</p>
</li>
<li>
<p><strong>Write and Read Times Without Compression</strong>: The fastest write (0.1174 ms) and read (0.328472 ms) times occur when no compression is applied, which is expected since compression and decompression introduce overhead.</p>
</li>
</ul>
<p>Let‚Äôs exclude the results for uncompressed data and identify the best configurations for write and read times:</p>
<p><strong>Best Write Time with Compression:</strong></p>
<pre><code class="language-q">q)select writeTime, lbs, alg, lvl from (select from results where alg&lt;&gt;0) where writeTime=min writeTime
writeTime lbs alg lvl
---------------------
0.153473  17  2   0  
</code></pre>
<p>The most favourable write time (0.153473 ms) occurs with the <em>gzip</em> algorithm at level 0 and an LBS of 17.</p>
<p><strong>Best Read Time with Compression:</strong></p>
<pre><code class="language-q">q)select readTime, lbs, alg, lvl from (select from results where alg&lt;&gt;0) where readTime=min readTime
readTime lbs alg lvl
--------------------
0.364619 13  4   12 
</code></pre>
<p>The most favourable read time (0.364619 ms) occurs with the <em>lz4hc</em> algorithm at level 12 and an LBS of 13.</p>
<h2 id="impact-of-algorithm-level-on-compression-performance"><a class="header" href="#impact-of-algorithm-level-on-compression-performance">Impact of Algorithm Level on Compression Performance</a></h2>
<p>In this section, we explore how varying the algorithm level affects compression performance. Using the results from the <a href="#generalised-compression-testing-with-random-data">previous section</a>, we focus on the <em>zstd</em> algorithm with a fixed LBS of 17 to analyse performance trends.</p>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<p>The below query can be used to gather the results:</p>
<pre><code class="language-q">q)select lvl, compFactor, writeTime, readTime from results where alg=5, lbs=17
lvl compFactor writeTime readTime
---------------------------------
-7  4.057967   0.315761  0.602378
-6  4.05925    0.29988   0.540294
-5  4.055668   0.313296  0.6288  
-4  4.056856   0.299043  0.636049
..
</code></pre>
<h3 id="visualisation"><a class="header" href="#visualisation">Visualisation</a></h3>
<p>To better understand these trends, the following graph illustrates the relationship between the algorithm level and the performance metrics:</p>
<p><img src="images/longs_alg5_lbs17.png" title="Changing Level Performance of the zstd Algorithm for a List of 10,000 Longs (LBS = 17)" alt="Changing Level Performance of the zstd Algorithm for a List of 10,000 Longs (LBS = 17)"></p>
<h3 id="observations-1"><a class="header" href="#observations-1">Observations</a></h3>
<ul>
<li>
<p><strong>Read Time</strong>: The read time remains relatively constant across levels, showing no significant variation.</p>
</li>
<li>
<p><strong>Compression Factor</strong>: The compression factor is generally stable, with a slight ‚Äúbump‚Äù observed at levels 1 and 2, indicating better compression efficiency at these levels.</p>
</li>
<li>
<p><strong>Write Time</strong>: Write time exhibits an exponential increase as the level rises, highlighting the trade-off between compression level and write performance.</p>
</li>
</ul>
<p>This analysis demonstrates that if constrained to the <em>zstd</em> algorithm with an LBS of 17, levels 1 or 2 are optimal. These levels achieve the maximum compression factor while keeping write time low.</p>
<h2 id="impact-of-logical-block-size-lbs-on-compression-performance"><a class="header" href="#impact-of-logical-block-size-lbs-on-compression-performance">Impact of Logical Block Size (LBS) on Compression Performance</a></h2>
<p>This section examines how varying the Logical Block Size (LBS) affects compression performance. For consistency, we analyse results using the <em>zstd</em> algorithm at a fixed level of 18.</p>
<h3 id="results-1"><a class="header" href="#results-1">Results</a></h3>
<p>The below query can be used to gather the results:</p>
<pre><code class="language-q">q)select lbs, compFactor, writeTime, readTime from results where alg=5, lvl=18
lbs compFactor writeTime readTime
---------------------------------
12  3.419139   18.3573   0.55395 
13  3.545852   21.61034  0.513634
14  3.787947   25.07718  0.686512
15  3.907031   14.57396  0.636689
16  4.059368   15.26676  0.68913 
17  4.155016   14.82453  0.563237
18  4.155016   14.19188  0.650421
19  4.155016   14.71257  0.675492
20  4.155016   14.67119  0.833243
</code></pre>
<h3 id="visualisation-1"><a class="header" href="#visualisation-1">Visualisation</a></h3>
<p>The graph below visualizes how the compression factor, write time, and read time vary with LBS:</p>
<p><img src="images/longs_alg5_lvl18.png" title="Changing LBS Performance of the zstd Algorithm for a List of 10,000 Longs (Level = 18)" alt="Changing LBS Performance of the zstd Algorithm for a List of 10,000 Longs (Level = 18)"></p>
<h3 id="observations-2"><a class="header" href="#observations-2">Observations</a></h3>
<ul>
<li>
<p><strong>Compression Factor</strong>: The compression factor steadily increases as the LBS grows, peaking at LBS values 17‚Äì20.</p>
</li>
<li>
<p><strong>Write Time</strong>: Write time initially rises with increasing LBS but stabilises and even slightly decreases beyond LBS 14.</p>
</li>
<li>
<p><strong>Read Time</strong>: Read time remains relatively constant across the range of LBS values, with minor variations.</p>
</li>
</ul>
<p>Based on these results, if the <em>zstd</em> algorithm is used at level 18, the optimal choice of LBS is 17 or 18, depending on whether read or write performance takes priority. These configurations maximise the compression factor while maintaining stable read and write times, offering a balanced trade-off between efficiency and performance.</p>
<h2 id="structure-and-size-of-data"><a class="header" href="#structure-and-size-of-data">Structure and Size of Data</a></h2>
<p>Compression performance can be significantly influenced by the structure and size of the data.</p>
<p>This section explores the effects of sorted, contiguous, and larger datasets on compression performance, comparing the results to the unsorted, smaller dataset analysed earlier.</p>
<p>For consistency, each test was performed with a fresh Q session using the same random seed, ensuring direct comparability of results.</p>
<h3 id="sorted-data"><a class="header" href="#sorted-data">Sorted Data</a></h3>
<p>To assess the impact of sorting, we rerun the general random data test seen <a href="#generalised-compression-testing-with-random-data">previously</a>, with the data sorted in ascending order. Sorting is achieved using the <code>asc</code> keyword in Q.</p>
<pre><code class="language-q">// Run the test - Takes approx. 30 minutes
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{asc 10000?1000}];
</code></pre>
<p><strong>Summary of Results</strong></p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 41.2923  0.9974073 23.22625 
writeTime  238.3535 0.14515   15.27876 
readTime   1.084563 0.183848  0.3457299
</code></pre>
<p><strong>Analysis</strong></p>
<p>Compared to the unsorted data <a href="#running-the-test">summary table</a>, sorting results in a dramatic increase in both the maximum and average compression factors, demonstrating significant space-saving potential.</p>
<p>However, there is a small penalty in terms of read and write times, as seen in the increase in their maximum and average values. Additionally, if the data isn‚Äôt already sorted, the time required for sorting must also be factored in.</p>
<h3 id="contiguous-data"><a class="header" href="#contiguous-data">Contiguous Data</a></h3>
<p>Contiguous ordering arranges identical values side by side, enhancing compression opportunities.</p>
<p>For example:</p>
<pre><code>Contiguous: 3 3 3 3 1 1 1 2 2
Not contiguous: 3 1 2 1 3 1 2 3 3
</code></pre>
<p>We transform the random data into a contiguous order by grouping identical values using <code>group</code> and then flattening the result with <code>raze</code>.</p>
<pre><code class="language-q">// Run the test - Takes approx. 30 minutes
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{raze d group d:10000?1000}];
</code></pre>
<p><strong>Summary of Results</strong></p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 32.44508 0.9974073 20.15545 
writeTime  218.1142 0.120421  12.29244 
readTime   1.102754 0.19812   0.3532618
</code></pre>
<p><strong>Analysis</strong></p>
<p>Contiguous data demonstrates a significant increase in compression factors compared to unsorted data. While the improvements are not as pronounced as those seen with sorted data, the degradation in read and write times is less severe.</p>
<p>Contiguous data therefore offers a balance between space-saving benefits and read/write performance, making it a practical alternative to sorting.</p>
<h3 id="larger-data"><a class="header" href="#larger-data">Larger Data</a></h3>
<p>Compression performance can also vary based on dataset size.</p>
<p>We reran the test with a larger list of 1,000,000 longs to evaluate its effect on compression.</p>
<pre><code class="language-q">// Run the test - Takes approx. 8 hours
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{1000000?1000}];
</code></pre>
<p><strong>Summary of Results</strong></p>
<pre><code class="language-q">metric     maximum  minimum   average 
--------------------------------------
compFactor 4.985321 0.9980438 3.734221
writeTime  759141   3.421783  2301.216
readTime   5.054386 0.4867    1.579741
</code></pre>
<p><strong>Analysis</strong></p>
<p>The larger dataset achieves slightly improved compression factors due to increased redundancy and repetition within the data. However, write and read times are significantly longer, which is expected given the greater volume of data being processed.</p>
<h2 id="different-datatypes"><a class="header" href="#different-datatypes">Different Datatypes</a></h2>
<p>So far, we have focused exclusively on the long datatype. However, the tests described earlier can be applied to any datatype in Q.</p>
<p>This section explores the impact of compression on two additional datatypes: boolean (a simpler datatype) and symbol (a more complex datatype).</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>In Q/KDB+, a boolean is a single-byte (8-bit) value that represents one of two possible states: true (<code>1b</code>) or false (<code>0b</code>). The simplicity of its structure and the high likelihood of repeated values make it an interesting candidate for compression.</p>
<h4 id="general-test"><a class="header" href="#general-test">General Test</a></h4>
<p>The test was rerun for a random list of 10,000 booleans:</p>
<pre><code class="language-q">// Run the test - Takes approx. 25 minutes
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{10000?0b}];
</code></pre>
<p><strong>Summary of Results</strong></p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 5.844129 0.9928628 4.395721 
writeTime  6.01018  0.109531  1.858013 
readTime   0.643794 0.151092  0.2843463
</code></pre>
<p><strong>Analysis</strong></p>
<p>Compared to the results for longs (<a href="#running-the-test">summary table</a>), booleans show:</p>
<ul>
<li><strong>Higher compression factors</strong>: The simpler structure and greater redundancy in boolean data improve compression.</li>
<li><strong>Faster read and write times</strong>: Smaller memory requirements for booleans contribute to quicker operations.</li>
</ul>
<h4 id="sorted-test"><a class="header" href="#sorted-test">Sorted Test</a></h4>
<p>The test was repeated for a sorted list of 10,000 booleans.</p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 120.6747 0.9928628 96.03797 
writeTime  2.937618 0.109034  0.1614437
readTime   0.708015 0.174412  0.2824265
</code></pre>
<p><strong>Analysis</strong></p>
<p>Sorting results in dramatic improvements in compression performance:</p>
<ul>
<li>The average compression factor jumps to 96, significantly outperforming sorted longs.</li>
<li>The write times are notably reduced, reflecting the efficient encoding of long runs of identical values in sorted boolean data.</li>
</ul>
<h4 id="large-dataset-test"><a class="header" href="#large-dataset-test">Large Dataset Test</a></h4>
<p>The test was scaled up to a list of 1,000,000 booleans to observe the effects of larger datasets.</p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 7.715686 0.9979961 4.951624 
writeTime  4447.509 0.563583  353.4303 
readTime   4.269396 0.277281  0.9963099
</code></pre>
<p><strong>Analysis</strong></p>
<ul>
<li>The compression factor increases with the larger dataset, reflecting the enhanced opportunities for compression in longer sequences of boolean values.</li>
<li>Write and read times scale up as expected, but the performance remains manageable due to the datatype‚Äôs simplicity.</li>
</ul>
<h3 id="symbol"><a class="header" href="#symbol">Symbol</a></h3>
<p>In Q/KDB+, the symbol datatype is analogous to a string in that it can represent sequences of characters. However, unlike strings, symbols are irreducible atomic values in Q/KDB+, with each symbol internally stored as an integer reference to a global dictionary of unique values. This representation makes symbols more complex than simpler data types like longs.</p>
<p>Given their structure, we can expect compression results for symbols to differ from those observed for longs.</p>
<h4 id="general-test-1"><a class="header" href="#general-test-1">General Test</a></h4>
<p>The compression test was rerun on a random list of 10,000, 3-character symbols:</p>
<pre><code class="language-q">// Run the test - Takes approx. 25 minutes
q)results:update writeTime%1e6, readTime%1e6 from .zipPerf.testAllRand[10;{10000?`3}];
</code></pre>
<p><strong>Summary of Results</strong></p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 2.053863 0.9968108 1.60796  
writeTime  5.365143 0.212508  1.26698  
readTime   1.450128 0.63938   0.9329227
</code></pre>
<p><strong>Analysis</strong></p>
<p>Compared to the results for longs (<a href="#running-the-test">summary table</a>), symbols exhibit the following key differences:</p>
<ul>
<li><strong>Lower Compression Factor</strong>: The more complex structure of symbols, coupled with potentially lower redundancy, reduces compression efficiency.</li>
<li><strong>Faster Write Times</strong>: While uncompressed long data is typically written faster than symbol data, the opposite trend is observed for compressed data. On average, compressed symbol data is written faster than compressed long data. This is likely because symbols tend to achieve lower compression ratios due to their more complex structure and representation, resulting in less computational overhead during the compression phase of the write process.</li>
</ul>
<h4 id="sorted-test-1"><a class="header" href="#sorted-test-1">Sorted Test</a></h4>
<p>The test was repeated for a sorted list of 10,000, 3-character symbols:</p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 10.58119 0.9968108 5.523273 
writeTime  4.763245 0.20937   1.005981 
readTime   1.161317 0.498619  0.6530251
</code></pre>
<p><strong>Analysis</strong></p>
<p>Sorting significantly impacts the compression performance of symbols:</p>
<ul>
<li><strong>Improved Compression Factor</strong>: Sorting amplifies redundancy, enabling compression algorithms to achieve a much higher compression factor. This effect is similar to that observed for longs and booleans.</li>
<li><strong>Improved Write and Read Times</strong>: Unlike longs, where sorting often increases write and read times, symbols see slight improvements. This might be due to better memory locality and more efficient processing of the sorted dictionary references.</li>
</ul>
<h4 id="contiguous-test"><a class="header" href="#contiguous-test">Contiguous Test</a></h4>
<p>The test was repeated for a contiguous list of 10,000, 3-character symbols:</p>
<pre><code class="language-q">metric     maximum  minimum   average  
---------------------------------------
compFactor 5.316126 0.9968108 3.300586 
writeTime  5.221845 0.221293  1.118578 
readTime   2.431121 0.520317  0.7447879
</code></pre>
<p><strong>Analysis</strong></p>
<p>The results for contiguous data fall between those for unsorted and fully sorted data:</p>
<ul>
<li><strong>Moderate Compression Factor Improvement</strong>: While not as effective as full sorting, contiguous ordering still groups identical symbols together, improving compression efficiency.</li>
<li><strong>Slight Improvements in Write and Read Times</strong>: The impact on performance is not as pronounced as with fully sorted data, reflecting the less regular structure of contiguous ordering.</li>
</ul>
<p>Overall, contiguous ordering provides a trade-off, achieving better compression factors than unsorted data without the full processing cost of sorting.</p>
<h4 id="large-dataset-test-1"><a class="header" href="#large-dataset-test-1">Large Dataset Test</a></h4>
<p>Finally, the test was scaled up to a list of 1,000,000, 3-character symbols to observe the impact of dataset size:</p>
<pre><code class="language-q">metric     maximum  minimum   average 
--------------------------------------
compFactor 2.139341 0.9980379 1.651971
writeTime  858.8655 6.676792  147.2629
readTime   70.03013 31.14028  40.45668
</code></pre>
<p><strong>Analysis</strong></p>
<ul>
<li><strong>Slightly Improved Compression Factor</strong>: Larger datasets provide more opportunities for redundancy, resulting in a modest increase in the compression factor.</li>
<li><strong>Significant Increase in Write and Read Times</strong>: As expected, processing times scale with dataset size. However, the faster write times relative to longs are maintained, suggesting symbols‚Äô internal structure benefits compression algorithms even for larger datasets.</li>
</ul>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>In this blog, we explored the performance of compression algorithms in Q/KDB+ across various dimensions, including algorithm choice, compression levels, logical block sizes, data structure, size, and datatype. Through extensive testing and analysis, we uncovered several key insights:</p>
<ol>
<li>
<p><strong>Compression Algorithms and Parameters</strong>: The choice of algorithm, level, and logical block size (LBS) has a significant impact on compression performance. Optimal settings often require balancing compression factor, write time, and read time based on specific use cases.</p>
</li>
<li>
<p><strong>Data Structure and Size</strong>: Sorting or grouping data (contiguous ordering) before compression can significantly improve compression factors, albeit at the cost of increased read and write times. Larger datasets often achieve better compression factors due to higher redundancy but require more time to process.</p>
</li>
<li>
<p><strong>Datatypes</strong>: Simpler datatypes like booleans generally achieve better compression performance compared to complex datatypes like symbols. However, symbols showed faster write times for compressed data, highlighting the role of underlying data representation in compression efficiency.</p>
</li>
</ol>
<p>Understanding these factors can help you make informed decisions when implementing compression in Q/KDB+, enabling you to tailor configurations to your specific data and performance needs. By leveraging the insights and methodologies discussed here, you can strike the right balance between storage efficiency and operational performance, optimising your use of compression in a production environment.</p>
<p>The results in this blog are a starting point. Real-world performance will depend on your specific data and workload, so it‚Äôs worth experimenting to find what works best for your use case.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="an-introduction-to-compression-in-qkdb"><a class="header" href="#an-introduction-to-compression-in-qkdb">An Introduction to Compression in Q/KDB+</a></h1>
<p><img src="images/compression.png" title="Cover Image" alt="Cover Image"></p>
<p>In the realm of computer science, compression refers to the process of reducing the size of a data object, such as a file, to save disk space and accelerate data transfer. In Q/KDB+, compression is both efficient and seamless: compressed data can be written to and read from disk without any additional effort on the user‚Äôs part. The language‚Äôs built-in methods for file handling automatically support both compressed and uncompressed formats, ensuring a smooth and transparent user experience.</p>
<p>This blog explores the fundamentals of compression in Q/KDB+, focusing on how to write and read compressed files. We will examine how compression operates for various data structures, such as tables and columns, and discuss how to apply compression settings effectively to optimise storage.</p>
<h2 id="writing-compressed-files"><a class="header" href="#writing-compressed-files">Writing Compressed Files</a></h2>
<p>In Q/KDB+, there are two main methods for writing compressed files:</p>
<ol>
<li>
<p><a href="#method-1-write-uncompressed-compress-later">Method 1</a>: Write data to disk in an uncompressed form, then compress it later on disk.</p>
</li>
<li>
<p><a href="#method-2-write-compressed-data-directly">Method 2</a>: Write data directly to disk in compressed form.</p>
</li>
</ol>
<p><strong>Method 1</strong> is beneficial when you want to bypass the overhead of compression during data saving, allowing it to be deferred until later when resources are less constrained. However, in most cases, it‚Äôs more efficient to compress the data and save it in a single step (<strong>Method 2</strong>).</p>
<h3 id="method-1-write-uncompressed-compress-later"><a class="header" href="#method-1-write-uncompressed-compress-later">Method 1: Write Uncompressed, Compress Later</a></h3>
<p>To write data to disk in an uncompressed form, use the <code>set</code> keyword:</p>
<pre><code class="language-q">q)`:/path/to/file set data
</code></pre>
<p>Once saved, you can compress the file on disk using the <code>set</code> keyword again, but this time specifying compression parameters:</p>
<pre><code class="language-q">q)(targetFile;blockSize;algorithm;level) set srcFile
</code></pre>
<p>Where:</p>
<ul>
<li><code>targetFile</code> - The path to the compressed file.</li>
<li><code>blockSize</code> - The <a href="#logical-block-size">logical block size</a>, determining how much data to compress at a time.</li>
<li><code>algorithm</code> - The <a href="#compression-algorithms">compression algorithm</a> to use.</li>
<li><code>level</code> - The <a href="#compression-algorithms">compression (zip) level</a>.</li>
<li><code>srcFile</code> - The path to the uncompressed source file.</li>
</ul>
<blockquote class="blockquote-tag blockquote-tag-note">
<p class="blockquote-tag-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>Performance depends heavily on the number of disk seeks. Placing the source and target files on separate physical disks can reduce seek time and improve performance.</p>
</blockquote>
<p><strong>Example</strong></p>
<p>Let‚Äôs create a list of random data:</p>
<pre><code class="language-q">q)show data:1000?100 // List of 1000 random longs between 0 and 100
7 62 89 15 9 37 23..
</code></pre>
<p>Write the data to disk in uncompressed form:</p>
<pre><code class="language-q">q)`:data set data
`:data
</code></pre>
<p>Check the file‚Äôs size on disk:</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     12:39           8016 data
</code></pre>
<p>Now, compress the uncompressed file:</p>
<pre><code class="language-q">// Compress using the q IPC compression algorithm
q)(`:compressedData1;16;1;0) set `:./data
`:compressedData1
</code></pre>
<p>Verify the compressed file size:</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     12:51           2297 compressedData1
-a---l        02/10/2024     12:39           8016 data
</code></pre>
<p>As shown, the compressed file is much smaller than the uncompressed version.</p>
<h3 id="method-2-write-compressed-data-directly"><a class="header" href="#method-2-write-compressed-data-directly">Method 2: Write Compressed Data Directly</a></h3>
<p>To compress and save data directly to disk in one step, use the <code>set</code> keyword with compression parameters:</p>
<pre><code class="language-q">q)(targetFile;blockSize;algorithm;level) set data
</code></pre>
<p>Where <code>data</code> is any Q object you wish to save in a compressed format.</p>
<p><strong>Example</strong></p>
<p>Using the same random data from the previous example, compress and save it directly:</p>
<pre><code class="language-q">q)(`:compressedData2;16;1;0) set data
`:compressedData2
</code></pre>
<p>Verify the compressed file size:</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     12:51           2297 compressedData1
-a---l        02/10/2024     13:05           2297 compressedData2
-a---l        02/10/2024     12:49           8016 data
</code></pre>
<p>The compressed file <code>compressedData2</code> is the same size as <code>compressedData1</code>, showing that the compression methods produce an equivalent result.</p>
<h3 id="appending-to-compressed-data"><a class="header" href="#appending-to-compressed-data">Appending to Compressed Data</a></h3>
<p>It is also possible to append data to a compressed file using the <code>upsert</code> keyword. This allows you to add more data without needing to decompress the existing file:</p>
<pre><code class="language-q">q)`:compressedData2 upsert 1000?100 // Append another 1000 random longs
`:compressedData2
</code></pre>
<p>Check the file‚Äôs size after appending:</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     12:51           2297 compressedData1
-a---l        02/10/2024     13:15           4403 compressedData2
-a---l        02/10/2024     12:49           8016 data
</code></pre>
<p>We can see that the size of <code>compressedData2</code> has increased after appending more data.</p>
<h2 id="reading-compressed-files"><a class="header" href="#reading-compressed-files">Reading Compressed Files</a></h2>
<p>Reading data from a compressed file in Q/KDB+ is identical to reading from an uncompressed file, both done using the <code>get</code> keyword:</p>
<pre><code class="language-q">q)get `:/path/to/file
</code></pre>
<p><strong>Example</strong></p>
<p>Let‚Äôs read the files created in the previous examples:</p>
<pre><code class="language-q">q)get `:data
7 62 89 15 9 37 23..
q)get `:compressedData1
7 62 89 15 9 37 23..
</code></pre>
<p>As shown, from the user‚Äôs perspective, reading data is the same whether it‚Äôs stored in compressed or uncompressed form.</p>
<p>However, there is a performance difference when reading compressed vs. uncompressed data:</p>
<pre><code class="language-q">// Create large uncompressed and compressed files
q)bigData:100000000?100
q)`:bigData set bigData
`:bigData
q)(`:bigDataCompressed;16;1;0) set bigData
`:bigDataCompressed

// Time and space statistics
q)\ts get `:bigData
0 560
q)\ts get `:bigDataCompressed
36 459472
</code></pre>
<p>In this case, reading the compressed file takes slightly longer and consumes significantly more memory than reading the uncompressed version.</p>
<h2 id="logical-block-size"><a class="header" href="#logical-block-size">Logical Block Size</a></h2>
<p>The logical block size (LBS) is a crucial parameter that dictates the amount of data compressed in each block. This size plays a significant role in both compression efficiency and performance during data access.</p>
<h3 id="impact-on-compression"><a class="header" href="#impact-on-compression">Impact on Compression</a></h3>
<p>A larger LBS allows for better identification of repeated values within the data, which can lead to a better compression ratio. By processing more data at once, the compressor has a greater chance of finding redundancies and achieving more effective compression.</p>
<p>However, a larger block size also influences the decompression process. If the LBS is set too high compared to the amount of data typically accessed during queries, it can lead to excessive and unnecessary decompression work. This inefficiency can slow down query performance as the system processes more data than needed at once.</p>
<h3 id="possible-values"><a class="header" href="#possible-values">Possible Values</a></h3>
<p>The LBS can be set to a power of two between 12 and 20. Here‚Äôs a table mapping each LBS value to its corresponding block size in bytes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>LBS Value</th><th>Physical Size</th></tr>
</thead>
<tbody>
<tr><td>12</td><td>4 kB</td></tr>
<tr><td>13</td><td>8 kB</td></tr>
<tr><td>14</td><td>16 kB</td></tr>
<tr><td>15</td><td>32 kB</td></tr>
<tr><td>16</td><td>64 kB</td></tr>
<tr><td>17</td><td>128 kB</td></tr>
<tr><td>18</td><td>256 kB</td></tr>
<tr><td>19</td><td>512 kB</td></tr>
<tr><td>20</td><td>1 MB</td></tr>
</tbody>
</table>
</div>
<p>Attempting to set an LBS outside this range results in an error. For example:</p>
<pre><code class="language-q">q)(`:data;11;1;0) set data
'bad blockSize 2048 for data$
  [0]  (`:data;11;1;0) set data
                       ^

q)(`:data;21;1;0) set data
'bad blockSize 2097152 for data$
  [0]  (`:data;21;1;0) set data
                       ^
</code></pre>
<p>Choosing the appropriate LBS value can impact both compression efficiency and speed. Larger values can improve compression ratios by capturing more repeated data patterns but may also slow down compression.</p>
<h3 id="system-constraints"><a class="header" href="#system-constraints">System Constraints</a></h3>
<p>The minimum LBS is bound by the system‚Äôs allocation granularity. If the block size is smaller than this granularity, it could result in wasted space. Typical values for allocation granularity include:</p>
<ul>
<li>AMD64: 4 kB</li>
<li>SPARC: 8 kB</li>
<li>Windows: 64 kB (default)</li>
<li>Apple Silicon: 16 kB</li>
</ul>
<p>When selecting a LBS, it‚Äôs important to consider the minimum allocation granularity across all platforms that will access the files. Failing to do so may result in sub-optimal performance.</p>
<h2 id="compression-algorithms"><a class="header" href="#compression-algorithms">Compression Algorithms</a></h2>
<p>As of Q/KDB+ version 4.1, the following compression algorithms are available:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Number</th><th>Level</th></tr>
</thead>
<tbody>
<tr><td>none</td><td>0</td><td>0</td></tr>
<tr><td>q IPC</td><td>1</td><td>0</td></tr>
<tr><td>gzip</td><td>2</td><td>0 - 9</td></tr>
<tr><td>snappy</td><td>3</td><td>0</td></tr>
<tr><td>lz4hc</td><td>4</td><td>0 - 16</td></tr>
<tr><td>zstd</td><td>5</td><td>-7 - 22</td></tr>
</tbody>
</table>
</div>
<p>The <code>Number</code> column indicates the value to be supplied as the algorithm parameter during compression. The <code>Level</code> column denotes the range of possible compression levels for each algorithm.</p>
<p><strong>Example Usage</strong></p>
<p>You can specify the algorithms and levels as follows:</p>
<pre><code class="language-q">q)(16;1;0)  // Using q IPC compression algorithm with level 0
q)(16;2;6)  // Using gzip compression algorithm with level 6
q)(16;5;-2) // Using zstd compression algorithm with level -2
</code></pre>
<p>The q IPC algorithm is built into Q/KDB+ and is always available. In contrast, the other algorithms depend on external libraries, which must be installed on your system to function properly. For more information on meeting the requirements for each algorithm, see <a href="https://code.kx.com/q/kb/file-compression/#requirements">Requirements</a>.</p>
<p>If Q/KDB+ cannot access an algorithm, it will raise an error. For example:</p>
<pre><code class="language-q">q)(`:data;16;2;6) set data // Attempting to use gzip algorithm
'zlib libs required to compress data$. The specified module could not be found.
  [0]  (`:data;16;2;6) set data
                       ^
</code></pre>
<pre><code class="language-q">q)(`:data;16;3;0) set data // Attempting to use snappy algorithm
'snappy libs required to compress data$. The specified module could not be found.
  [0]  (`:data;16;3;0) set data
                       ^
</code></pre>
<h2 id="compression-defaults"><a class="header" href="#compression-defaults">Compression Defaults</a></h2>
<p>In Q/KDB+, we can set default compression parameters using <code>.z.zd</code>, allowing us to compress files without explicitly passing these parameters to <code>set</code> each time. This can simplify file writing operations when compression is needed consistently across multiple files.</p>
<p>By default, these compression parameters are not set:</p>
<pre><code class="language-q">q).z.zd
'.z.zd
  [0]  .z.zd
       ^
</code></pre>
<p>For example, in earlier cases, we saved a file (<code>data</code>) without compression. Now, let‚Äôs apply default compression settings:</p>
<pre><code class="language-q">q).z.zd:(16;1;0) // Set default values (blockSize, algorithm, zipLevel)
q)`:compressedData3 set data
</code></pre>
<p>This will compress the data and save it to a new file, <code>compressedData3</code>, without needing to specify compression parameters explicitly to <code>set</code>.</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     12:51           2297 compressedData1
-a---l        02/10/2024     13:15           4403 compressedData2
-a---l        02/10/2024     13:22           2297 compressedData3
-a---l        02/10/2024     12:49           8016 data
</code></pre>
<p>As shown, even though no explicit compression parameters were passed to <code>set</code>, the data was saved in compressed form in <code>compressedData3</code> using the default settings.</p>
<h3 id="removing-defaults"><a class="header" href="#removing-defaults">Removing Defaults</a></h3>
<p>You can reset or remove the compression defaults by either setting <code>.z.zd</code> values to zero or expunging the setting altogether:</p>
<pre><code class="language-q">q).z.zd:3#0 // Reset default compression settings to 0
</code></pre>
<p>or</p>
<pre><code class="language-q">q)\x .z.zd // Expunge .z.zd
</code></pre>
<p>After removing the defaults, the system reverts to not applying compression unless explicitly specified.</p>
<h3 id="handling-file-extensions"><a class="header" href="#handling-file-extensions">Handling File Extensions</a></h3>
<p>It‚Äôs important to note that files with extensions, such as <code>.txt</code>, will not be compressed by default, even if the compression defaults are set:</p>
<pre><code class="language-q">q).z.zd
'.z.zd
  [0]  .z.zd
       ^
q)`:data1.txt set data
`:data1.txt
q).z.zd:(16;1;0)
q)`:data2.txt set data
`:data2.txt
</code></pre>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     13:34           8016 data1.txt
-a---l        02/10/2024     13:34           8016 data2.txt
</code></pre>
<p>Both <code>data1.txt</code> and <code>data2.txt</code> are the same size because no compression was applied to <code>data2.txt</code>, even though defaults were set. Files with extensions remain uncompressed unless explicitly handled.</p>
<h2 id="compression-statistics"><a class="header" href="#compression-statistics">Compression Statistics</a></h2>
<p>Q/KDB+ provides an internal function, <code>-21!</code>, to view compression statistics for files stored on disk. This allows you to inspect how effectively a file has been compressed. The syntax is as follows:</p>
<pre><code class="language-q">q)-21!`:/path/to/file
</code></pre>
<p>For uncompressed files, this command returns nothing:</p>
<pre><code class="language-q">q)-21!`:data
q)
</code></pre>
<p>However, for compressed files, it returns a dictionary with detailed statistics:</p>
<pre><code class="language-q">q)-21!`:compressedData1
compressedLength  | 2297
uncompressedLength| 8016
algorithm         | 1i
logicalBlockSize  | 16i
zipLevel          | 0i

q)-21!`:compressedData2
compressedLength  | 4403
uncompressedLength| 16016
algorithm         | 1i
logicalBlockSize  | 16i
zipLevel          | 0i
</code></pre>
<p>The statistics include:</p>
<ul>
<li><code>compressedLength</code> - Size of the file after compression.</li>
<li><code>uncompressedLength</code> - Original size of the data before compression.</li>
<li><code>algorithm</code> - The algorithm used for compression.</li>
<li><code>logicalBlockSize</code> - The size of each logical block used during compression.</li>
<li><code>zipLevel</code> - The level of compression applied.</li>
</ul>
<p>We can easily calculate the compression factor (the ratio of uncompressed size to compressed size) from this data:</p>
<pre><code class="language-q">q)stats:-21!`:compressedData1
q)(%). stats`uncompressedLength`compressedLength
3.489769
</code></pre>
<p>In this example, the compression factor is approximately 3.49, meaning the file size has been reduced to about 1/3.49 or 29% of its original size.</p>
<h2 id="compressing-and-decompressing-tables"><a class="header" href="#compressing-and-decompressing-tables">Compressing and Decompressing Tables</a></h2>
<p>In Q/KDB+, tables are a common data structure, and the system offers robust methods for compressing and decompressing tables, whether they are flat or splayed. Below, we outline key strategies for efficiently handling table compression.</p>
<h3 id="flat-tables"><a class="header" href="#flat-tables">Flat Tables</a></h3>
<p>Flat tables are stored in a single file, so compression and decompression work the same way as with simpler lists or vectors. To save a flat table in compressed form, you simply pass the desired parameters to <code>set</code>:</p>
<pre><code class="language-q">q)(targetFile;blockSize;algorithm;level) set table
</code></pre>
<p><strong>Example</strong></p>
<p>Let‚Äôs create a simple flat table containing symbols, quantities, and prices (<code>sym</code>, <code>qty</code>, and <code>px</code>):</p>
<pre><code class="language-q">q)n:10000 // Number of rows
q)show t:([] sym:n?`3; qty:n?100; px:n?100f)
sym qty px
----------------
cbl 6   39.27524
afi 67  51.70911
pga 95  51.59796
..
</code></pre>
<p>Now we save it both uncompressed and compressed:</p>
<pre><code class="language-q">q)`:table set t // Uncompressed
`:table
q)(`:tableCompressed;16;1;0) set t // Compressed
`:tableCompressed
</code></pre>
<p>We can then compare the file sizes:</p>
<pre><code class="language-powershell">C:\&gt; ls

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        02/10/2024     16:54         200046 table
-a---l        02/10/2024     16:54         159152 tableCompressed
</code></pre>
<p>As expected, the compressed file is smaller.</p>
<h4 id="reading-compressed-tables"><a class="header" href="#reading-compressed-tables">Reading Compressed Tables</a></h4>
<p>Reading tables back into memory is seamless with the <code>get</code> function, whether they are compressed or not:</p>
<pre><code class="language-q">q)get`:table
sym qty px
----------------
cbl 6   39.27524
afi 67  51.70911
pga 95  51.59796
..

q)get`:tableCompressed
sym qty px
----------------
cbl 6   39.27524
afi 67  51.70911
pga 95  51.59796
..
</code></pre>
<p>Both commands will return the same table, but with different performance and memory usage characteristics.</p>
<h3 id="splayed-tables"><a class="header" href="#splayed-tables">Splayed Tables</a></h3>
<p>For large tables, it‚Äôs often useful to ‚Äúsplay‚Äù them, meaning each column is stored separately on disk. Compression can still be applied, but each column is handled individually.</p>
<h4 id="creating-an-uncompressed-splayed-table"><a class="header" href="#creating-an-uncompressed-splayed-table">Creating an Uncompressed Splayed Table</a></h4>
<p>We can splay the table <code>t</code> to a directory:</p>
<pre><code class="language-q">q)`:uncompressed/t/ set .Q.en[`:uncompressed;t]
`:uncompressed/t/
</code></pre>
<p>This will store each column as a separate file inside the <code>t</code> directory.</p>
<pre><code class="language-powershell">C:\&gt; ls .\uncompressed\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
dar--l        03/10/2024     11:59                t
-a---l        03/10/2024     11:59          14924 sym

C:\&gt; ls .\uncompressed\t\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        03/10/2024     11:59             19 .d
-a---l        03/10/2024     11:59          80016 px
-a---l        03/10/2024     11:59          80016 qty
-a---l        03/10/2024     11:59          84096 sym
</code></pre>
<h4 id="creating-a-compressed-splayed-table"><a class="header" href="#creating-a-compressed-splayed-table">Creating a Compressed Splayed Table</a></h4>
<p>To compress a splayed table, we pass the same compression parameters used earlier:</p>
<pre><code class="language-q">q)(`:compressed/t/;16;1;0) set .Q.en[`:compressed;t]
`:compressed/t/
</code></pre>
<p>After saving the compressed splayed table, we can again compare file sizes:</p>
<pre><code class="language-powershell">C:\&gt; ls .\compressed\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
dar--l        03/10/2024     12:02                t
-a---l        03/10/2024     12:02          14924 sym

C:\&gt; ls .\compressed\t\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        03/10/2024     12:02             75 .d
-a---l        03/10/2024     12:02          80080 px
-a---l        03/10/2024     12:02          21559 qty
-a---l        03/10/2024     12:02          33397 sym
</code></pre>
<h4 id="column-files"><a class="header" href="#column-files">Column Files</a></h4>
<p>The compression significantly reduces the size of the <code>qty</code> and <code>sym</code> column files, but interestingly, the <code>px</code> file increases in size after compression. (The <code>.d</code> file, which holds the column order, also grows slightly but remains small in comparison.) This highlights a key point: not all columns compress well, and it would be ideal to apply compression selectively based on the characteristics of each column.</p>
<h4 id="column-by-column-compression"><a class="header" href="#column-by-column-compression">Column-by-Column Compression</a></h4>
<p>Since each column in a splayed table is stored as a separate file, Q/KDB+ allows for column-by-column compression. Different compression algorithms, levels, and block sizes can be assigned to each column individually. This flexibility is useful because certain columns, depending on factors such as data type, value repetition, and overall structure, may respond better to specific compression strategies. By selectively applying compression, you can optimise performance and storage efficiency without being limited to a single compression method across the entire table.</p>
<p>To apply column-specific compression to a splayed table, use the following syntax:</p>
<pre><code class="language-q">q)(dir;dic) set t
</code></pre>
<p>Where</p>
<ul>
<li><code>dir</code> - The path to the splayed table directory.</li>
<li><code>dic</code> - A dictionary that maps each column to its respective compression parameters.</li>
<li><code>t</code> - The table to be splayed.</li>
</ul>
<p>In the earlier example, the <code>px</code> column didn‚Äôt compress effectively, so we‚Äôll exclude it from compression:</p>
<pre><code class="language-q">q)show dic:`px`qty`sym!(0 0 0;16 1 0;16 1 0)
px | 0  0 0   // No compression on px
qty| 16 1 0
sym| 16 1 0
q)(`:compressedCByC/t/;dic) set .Q.en[`:compressedCByC;t]
`:compressedCByC/t/
</code></pre>
<p>This results in:</p>
<pre><code class="language-powershell">C:\&gt; ls .\compressedCByC\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
dar--l        03/10/2024     12:46                t
-a---l        03/10/2024     12:46          14924 sym

C:\&gt; ls .\compressedCByC\t\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        03/10/2024     12:46             19 .d
-a---l        03/10/2024     12:46          80016 px
-a---l        03/10/2024     12:46          21559 qty
-a---l        03/10/2024     12:46          33397 sym
</code></pre>
<p>The <code>px</code> column file remains the same size as in the uncompressed table. We can confirm that no compression was applied to <code>px</code>, while the <code>qty</code> and <code>sym</code> columns were successfully compressed using q IPC compression:</p>
<pre><code class="language-q">q)-21!`:compressedCByC/t/px

q)-21!`:compressedCByC/t/qty
compressedLength  | 21559
uncompressedLength| 80016
algorithm         | 1i
logicalBlockSize  | 16i
zipLevel          | 0i

q)-21!`:compressedCByC/t/sym
compressedLength  | 33397
uncompressedLength| 84096
algorithm         | 1i
logicalBlockSize  | 16i
zipLevel          | 0i
</code></pre>
<p><code>dic</code> can also include a null key to define default compression parameters for any columns not explicitly listed in the dictionary. This allows for flexible control over compression behaviour across multiple columns. For example:</p>
<pre><code class="language-q">q)show dic:``qty`sym!(0 0 0;16 1 0;16 1 0)
   | 0  0 0   // Default: No compression
qty| 16 1 0
sym| 16 1 0
</code></pre>
<p>In this case, columns not specified in the dictionary, like <code>px</code>, would automatically use the default compression (<code>0 0 0</code>), which applies no compression. This offers a concise way to manage compression policies while avoiding the need to specify every column individually.</p>
<h4 id="compress-a-splayed-table-on-disk"><a class="header" href="#compress-a-splayed-table-on-disk">Compress a Splayed Table on Disk</a></h4>
<p>If you already have a splayed table saved on disk that is too large to fit into memory, you can pass the splayed table‚Äôs path directly to <code>set</code>, allowing compression without needing to load the data in memory. Here‚Äôs an example of applying compression to the <code>uncompressed</code> splayed directory we created earlier:</p>
<pre><code class="language-q">q)(`:uncompressed/t/;dic) set `:uncompressed/t
`:uncompressed/t/
</code></pre>
<p>Now let‚Äôs check the files:</p>
<pre><code class="language-powershell">C:\&gt; ls .\uncompressed\t

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        03/10/2024     13:27             19 .d
-a----        03/10/2024     13:27          80016 px
-a---l        03/10/2024     13:27          21559 qty
-a---l        03/10/2024     13:27          33397 sym
</code></pre>
<p>You can see that the <code>qty</code> and <code>sym</code> files have been successfully compressed on disk.</p>
<h4 id="the-sym-file"><a class="header" href="#the-sym-file">The Sym File</a></h4>
<p>The file size of the <code>sym</code> file remains unchanged between the compressed and uncompressed versions. Let‚Äôs inspect the compression statistics to confirm:</p>
<pre><code class="language-q">q)-21!`:compressed/sym
q)
</code></pre>
<p>Since no output is returned, it indicates that the <code>sym</code> file was not compressed.</p>
<p>It‚Äôs important to note that the <code>sym</code> file should not be compressed for two key reasons:</p>
<ol>
<li><strong>Unique values</strong>: The <code>sym</code> file contains only distinct values (symbols), which typically doesn‚Äôt compress well since there‚Äôs no repetition in the data.</li>
<li><strong>Appending restrictions</strong>: Once compressed, the <code>sym</code> file becomes non-appendable, as illustrated below.</li>
</ol>
<pre><code class="language-q">q)(`:bad/t/;16;1;0) set .Q.en[`:bad;t] // Create a new splay
`:bad/t/
q)(`:bad/sym;16;1;0) set `:bad/sym     // Manually compress the sym file
`:bad/sym
q)-21!`:bad/sym                        // Check the sym file compression stats
compressedLength  | 14980
uncompressedLength| 14924
algorithm         | 1i
logicalBlockSize  | 16i
zipLevel          | 0i
</code></pre>
<p>Though the file is compressed, <code>compressedLength</code> is actually greater than <code>uncompressedLength</code>, confirming poor compression efficiency.</p>
<p>Furthermore, trying to append data to a compressed <code>sym</code> file results in an error:</p>
<pre><code class="language-q">q)(`:bad/t2/;16;1;0) set .Q.en[`:bad;([] sym:`a`b`c; val:1 2 3)] 
'no append to zipped enums: bad/sym
  [0]  (`:bad/t2/;16;1;0) set .Q.en[`:bad;([] sym:`a`b`c; val:1 2 3)]
                          ^
</code></pre>
<p>This shows that once a <code>sym</code> file is compressed, Q/KDB+ raises an error when attempting to append new symbol data. Compression offers little benefit for <code>sym</code> files and can restrict common operations, making it unsuitable for this specific file.</p>
<h4 id="appending-to-a-compressed-splayed-table"><a class="header" href="#appending-to-a-compressed-splayed-table">Appending to a Compressed Splayed Table</a></h4>
<p>Appending new data to compressed splayed tables works exactly the same as for uncompressed ones. Here‚Äôs an example of appending a few rows to the <code>compressedCByC</code> splayed table:</p>
<pre><code class="language-q">q)`:compressedCByC/t upsert .Q.en[`:.;] ([] sym:`a`b`c; qty:1 2 3; px:1 2 3f)
`:compressedCByC/t
q)\l compressedCByC // Load the splayed database
q)-5#t // Inspect the last 5 rows
sym qty px
----------------
ngh 89  99.18507
jic 28  23.3976
a   1   1
b   2   2
c   3   3
</code></pre>
<p>Checking the directory confirms that the file sizes have slightly increased due to the addition of the new rows:</p>
<pre><code class="language-powershell">C:\&gt; ls .\compressedCByC\t

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a---l        04/10/2024     16:00             19 .d
-a---l        04/10/2024     16:00          80040 px
-a---l        04/10/2024     16:00          21565 qty
-a---l        04/10/2024     16:00          33407 sym
</code></pre>
<p>As expected, the <code>qty</code>, <code>sym</code>, and <code>px</code> files have grown, reflecting the addition of new data.</p>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>In this blog, we explored the fundamentals of compression in Q/KDB+, focusing on how to write and read compressed files effectively. We discussed the significance of compression in optimising storage and enhancing data management, particularly regarding tables and columns. We also examined the implications of logical block size, emphasizing the trade-offs between compression efficiency and performance during data access.</p>
<p>Understanding these concepts is vital for effectively managing data in Q/KDB+. By applying the right compression techniques, you can maximise storage efficiency while minimising the performance overhead during query operations.</p>
<p>Check out <a href="#measuring-compression-performance-in-qkdb">part two</a> of this series on compression in Q/KDB+, where we will explore algorithm performance, analyse the efficiency of querying compressed data, benchmark various compression methods, and discuss practical strategies to optimise your compression choices.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="command-line-arguments-in-qkdb"><a class="header" href="#command-line-arguments-in-qkdb">Command Line Arguments in Q/KDB+</a></h1>
<p><img src="images/command_line_args.png" title="Cover Image" alt="Cover Image"></p>
<p>In Q/KDB+, command line arguments allow users to customise the behaviour of a session when it is started. By passing specific arguments, you can configure memory usage, port bindings, and even pre-load scripts, among other settings. This can be especially useful in automated environments or when dealing with large data sets that require specific resources.</p>
<p>Typically, a Q session is started by simply typing <code>q</code> in the command line or terminal:</p>
<pre><code class="language-powershell">C:\&gt; q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)
</code></pre>
<p>However, Q also supports additional arguments that can be passed after the <code>q</code> invocation to modify its behaviour. The general syntax looks like this:</p>
<pre><code class="language-powershell">q [file] [-option [params] ‚Ä¶ ]
</code></pre>
<h2 id="loading-files-and-directories"><a class="header" href="#loading-files-and-directories">Loading Files and Directories</a></h2>
<p>One of the simplest ways to initialise a Q session is by loading files or directories at start-up. The first argument you provide after invoking q is a file or directory that Q will automatically load upon launch. This is especially useful for preloading variables or scripts when starting a Q session.</p>
<p>For example, let‚Äôs consider a file called <code>test.q</code> with the following content:</p>
<pre><code class="language-q">a:10
</code></pre>
<p>To load this file when starting Q, simply pass it as the first argument:</p>
<pre><code class="language-q">C:\&gt; q test.q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)a
10
</code></pre>
<p>As you can see, the variable <code>a</code> from <code>test.q</code> is now available in the session.</p>
<h3 id="loading-multiple-files-from-a-directory"><a class="header" href="#loading-multiple-files-from-a-directory">Loading Multiple Files from a Directory</a></h3>
<p>Q also allows you to load multiple scripts from a directory by passing the directory name as the argument. In this case, all Q scripts in the directory will be executed in alphabetical order.</p>
<p>For example, consider a directory called <code>test</code> with the following files:</p>
<pre><code class="language-q">// test1.q
a:10
</code></pre>
<pre><code class="language-q">// test2.q
b:20
</code></pre>
<p>By passing the directory <code>test</code> to the Q command, both files are loaded:</p>
<pre><code class="language-q">C:\&gt; q test\
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)a
10
q)b
20
</code></pre>
<p>Here, both variables <code>a</code> and <code>b</code> are accessible because <code>test1.q</code> and <code>test2.q</code> were loaded sequentially.</p>
<h3 id="handling-non-q-files"><a class="header" href="#handling-non-q-files">Handling Non-Q Files</a></h3>
<p>If the directory contains non-Q compatible files (files without <code>.q</code>, <code>.k</code>, or <code>.s</code> extensions), Q will raise an error and halt the loading process:</p>
<pre><code class="language-q">C:\&gt; ls test\

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        13/09/2024     12:09              4 test1.q
-a----        13/09/2024     12:09              4 test2.q
-a----        13/09/2024     12:14             17 test3.txt


C:\&gt; q test\
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

'./test3.txt
  [0]  (.Q.lo)

 .Q )
</code></pre>
<p>To avoid such errors, ensure that all files in the directory have valid extensions like <code>.q</code>, <code>.k</code>, or <code>.s</code>.</p>
<h4 id="file-extensions-explained"><a class="header" href="#file-extensions-explained">File Extensions Explained</a></h4>
<ul>
<li>
<p><code>.q</code> ‚Äì Extension used for Q scripts. Files with the <code>.q</code> extension contain Q code that can be executed or loaded directly into the session.</p>
</li>
<li>
<p><code>.k</code> ‚Äì Extension associated with K scripts, the predecessor of Q. Files ending in <code>.k</code> can still be executed within Q, ensuring backward compatibility with older K code.</p>
</li>
<li>
<p><code>.s</code> ‚Äì Extension for SQL code (not to be confused with the more common use of <code>.s</code> for assembly source code files). For more information on using SQL in Q, see <a href="https://code.kx.com/insights/1.11/core/sql.html#running-sql">here</a>.</p>
</li>
</ul>
<h3 id="use-case-loading-databases"><a class="header" href="#use-case-loading-databases">Use Case: Loading Databases</a></h3>
<p>One practical and common use case for command-line arguments in Q is loading splayed or partitioned databases directly into a session. By passing the root directory of the database as an argument when launching Q, the system will automatically memory-map the data, making its contents available for immediate querying without needing to fully load it into memory.</p>
<p>This approach is particularly useful when working with large datasets, as memory-mapping allows Q to efficiently handle data on disk while still providing high-speed access. Here‚Äôs an example:</p>
<pre><code class="language-powershell">C:\&gt; ls db/t

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        16/09/2024     09:55             12 .d
-a----        16/09/2024     09:55             40 a
-a----        16/09/2024     09:55             40 b
</code></pre>
<pre><code class="language-q">C:\&gt; q db/
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)t
a b
---
1 4
2 5
3 6
</code></pre>
<p>In the above example, a splayed database located at the <code>db/</code> directory is loaded. The database contains a table <code>t</code>, which is instantly available in the Q session. This makes it possible to interact with large tables or partitions of data without the overhead of fully loading them into memory, which is crucial when working with vast amounts of time-series data or transactional records.</p>
<p>By leveraging memory-mapping, Q ensures that only the necessary parts of the data are accessed, optimising performance while maintaining minimal memory usage. This functionality makes Q an efficient choice for handling large-scale databases, especially in financial and real-time data environments where speed and resource management are critical.</p>
<p>This example demonstrates how easy it is to load a splayed or partitioned database with a simple command-line argument, highlighting Q‚Äôs ability to streamline database management and access.</p>
<h2 id="built-in-options"><a class="header" href="#built-in-options">Built-in Options</a></h2>
<p>Q provides several <a href="https://code.kx.com/q/basics/cmdline/">built-in command line options</a> that allow you to control various aspects of a Q session. These options follow the format:</p>
<pre><code>-? [param/s]
</code></pre>
<p>where <code>?</code> is replaced by a single lowercase or uppercase letter, and <code>[param/s]</code> represents optional parameters that configure the behaviour of the option.</p>
<h3 id="example-1-set-a-listening-port-with--p"><a class="header" href="#example-1-set-a-listening-port-with--p">Example 1: Set a Listening Port with <code>-p</code></a></h3>
<p>The <code>-p</code> option allows you to set a listening port for your Q process, which is essential when running Q as a server to handle client queries. For instance, to set the port to 5000, you would use:</p>
<pre><code class="language-q">C:\&gt; q -p 5000
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\p // Verify the port setting
5000i
</code></pre>
<p>To let Q choose any available ephemeral port, pass <code>0W</code> as the argument:</p>
<pre><code class="language-q">C:\&gt; q -p 0W
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\p // Check which port was automatically assigned
61411i
</code></pre>
<p>Alternatively, setting <code>-p 0</code> means Q will not listen on any port (which is also the default behaviour):</p>
<pre><code class="language-q">C:\&gt; q -p 0
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\p
0i
</code></pre>
<h3 id="example-2-set-a-workspace-memory-limit-with--w"><a class="header" href="#example-2-set-a-workspace-memory-limit-with--w">Example 2: Set a Workspace Memory Limit with <code>-w</code></a></h3>
<p>Since Q is an in-memory database, it‚Äôs important to manage memory usage carefully, especially in long-running processes. The <code>-w</code> option allows you to set a memory limit, preventing the Q process from consuming excessive system resources.</p>
<p>To set a memory limit of 1 GB, pass <code>1024</code> (since the value is in megabytes) as an argument to <code>-w</code>:</p>
<pre><code class="language-q">C:\&gt; q -w 1024
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).Q.w[]`wmax // Check memory limit (in bytes)
1073741824
</code></pre>
<p>If the process attempts to use more memory than the specified limit, it will terminate with a <code>-w abort</code> error. For example:</p>
<pre><code class="language-q">q)til 100000000 // Create a large list of longs
'-w abort
C:\&gt;
</code></pre>
<p>The default memory limit is 0, meaning no limit is enforced:</p>
<pre><code class="language-q">C:\&gt; q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).Q.w[]`wmax
0
</code></pre>
<h3 id="example-3-set-a-query-timeout-with--t"><a class="header" href="#example-3-set-a-query-timeout-with--t">Example 3: Set a Query Timeout with <code>-T</code></a></h3>
<p>In server setups, Q processes can execute queries from external clients. Ill-formed or long-running queries can monopolise resources, so the <code>-T</code> option is used to set a timeout for client queries. Any query exceeding this time limit will be aborted automatically.</p>
<p>To set a timeout of 5 seconds, along with a listening port on 5000, you would use:</p>
<pre><code class="language-q">C:\&gt; q -T 5 -p 5000
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\T // Verify the timeout setting
5i
</code></pre>
<p>Now, let‚Äôs set up another Q process to act as a client and query the server:</p>
<pre><code class="language-q">C:\&gt; q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)h:hopen 5000
q)h"(0&lt;){1+x}/1" // Infinite loop query
'stop
  [0]  h"(0&lt;){1+x}/1"
</code></pre>
<p>The server automatically killed the query after 5 seconds and returned a <code>'stop</code> error to the client.</p>
<blockquote>
<p><strong>Note:</strong> The timeout only applies to client queries. If you execute an infinite loop directly on the server itself, it will not be interrupted.</p>
</blockquote>
<p>The default timeout is 0, which means no timeout is enforced:</p>
<pre><code class="language-q">C:\&gt; q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\T
0i
</code></pre>
<h3 id="example-4-changing-values-after-start-up"><a class="header" href="#example-4-changing-values-after-start-up">Example 4: Changing Values After Start-Up</a></h3>
<p>The built-in command-line options provided during the start of a Q session are set automatically and persist throughout the session. However, the values of most options can be modified dynamically after the session starts using <em>system commands</em>, without restarting Q. This feature adds flexibility when working in Q environments, particularly when it‚Äôs necessary to adjust settings based on runtime conditions.</p>
<p>For example, you can adjust the listening port (<code>-p</code>) during a session:</p>
<pre><code class="language-q">C:\&gt; q -p 5000
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\p // Initially set to 5000
5000i 
q)\p 8000
q)\p // Now changed to 8000
8000i 
q).z.X // Raw command line unchanged
,"q"
"-p"
"5000"
</code></pre>
<p>In the above example, the port was initially set to 5000 using the command line, and then dynamically changed to 8000 within the Q session. Importantly, the raw command line (<code>.z.X</code>) remains unchanged, preserving the initial values passed during start-up (see <a href="#example-3-custom-and-built-in-options-together">below</a> for more on <code>.z.X</code>).</p>
<p>You can achieve the same result using the <code>system</code> keyword to invoke system commands:</p>
<pre><code class="language-q">C:\&gt; q -p 5000
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)system"p" // Check current port
5000i
q)system"p 8000"
q)system"p" // Port changed to 8000
8000i
</code></pre>
<p>This approach provides more flexibility by allowing you to modify system settings dynamically, based on the needs of your application or environment. Whether you need to change the port number or other built-in options, using system commands within Q gives you control and adaptability during runtime.</p>
<h2 id="custom-options"><a class="header" href="#custom-options">Custom Options</a></h2>
<p>Q also provides the flexibility to define your own custom command line options, which follow a similar syntax to the built-in options:</p>
<pre><code class="language-powershell">-myOpt [param/s]
</code></pre>
<h3 id="reserved-single-letter-option-names"><a class="header" href="#reserved-single-letter-option-names">Reserved Single-Letter Option Names</a></h3>
<p>It is important to note that Q reserves single-letter names exclusively for its built-in options. Even if a specific single-letter option is not currently in use, attempting to assign it as a custom option will result in an error. This ensures that future Q updates do not conflict with user-defined options.</p>
<pre><code class="language-powershell">C:\&gt; q -a 1 2 3
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

'a invalid
</code></pre>
<p>In this case, the single-letter option <code>-a</code> is reserved, and Q throws an error when trying to use it. To avoid such issues, always use multi-letter names for custom options to ensure compatibility.</p>
<h3 id="example-1-a-single-custom-option"><a class="header" href="#example-1-a-single-custom-option">Example 1: A Single Custom Option</a></h3>
<p>In this example, we pass a custom option <code>-myOpt</code> with a value of <code>10</code>:</p>
<pre><code class="language-q">C:\&gt; q -myOpt 10
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)
</code></pre>
<p>You can inspect the custom command line option using the <code>.z.x</code> system variable, which captures the custom options passed during start-up:</p>
<pre><code class="language-q">q).z.x
"-myOpt"
"10"
</code></pre>
<p>Here, <code>.z.x</code> shows that the custom option <code>-myOpt</code> and its value 10 were correctly passed to the Q session.</p>
<h3 id="example-2-multiple-custom-options"><a class="header" href="#example-2-multiple-custom-options">Example 2: Multiple Custom Options</a></h3>
<p>You can also pass multiple custom options. In this example, we use two custom options, <code>-myOpt1</code> and <code>-myOpt2</code>, with values of <code>10</code> and <code>hello world</code>, respectively:</p>
<pre><code class="language-q">C:\&gt; q -myOpt1 10 -myOpt2 hello world
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).z.x
"-myOpt1"
"10"
"-myOpt2"
"hello"
"world"
</code></pre>
<p>Notice that <code>.z.x</code> splits <code>hello world</code> into two separate arguments. On the command line, spaces are treated as argument separators. If you intended to pass <code>hello world</code> as a single argument, you need to wrap the argument in quotes:</p>
<pre><code class="language-q">C:\&gt; q -myOpt1 10 -myOpt2 'hello world'
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).z.x
"-myOpt1"
"10"
"-myOpt2"
"hello world"
</code></pre>
<p>Now <code>.z.x</code> correctly captures <code>hello world</code> as a single argument.</p>
<h3 id="example-3-custom-and-built-in-options-together"><a class="header" href="#example-3-custom-and-built-in-options-together">Example 3: Custom and Built-in Options Together</a></h3>
<p>You can mix custom options with Q‚Äôs built-in options. In this example, we pass a custom option <code>-myOpt</code> and the built-in <code>-p</code> option to set a listening port:</p>
<pre><code class="language-q">C:\&gt; q -myOpt 10 -p 5000
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).z.x
"-myOpt"
"10"
</code></pre>
<p>Here, <code>.z.x</code> only displays the custom option <code>-myOpt</code>. This is because <code>.z.x</code> is designed to capture only the custom command line options, not the built-in ones.</p>
<p>To view the entire command line, including built-in options, you can use <code>.z.X</code> (uppercase X), which provides the raw command line used to start the Q session:</p>
<pre><code class="language-q">q).z.X
"C:\\q\\w64\\q.exe"
"-myOpt"
"10"
"-p"
"5000"
</code></pre>
<p>The first item in this list is the path to the Q executable, followed by all the options passed in the command line, including both custom and built-in options, in the order they were provided.</p>
<h2 id="parsing-the-command-line-1"><a class="header" href="#parsing-the-command-line-1">Parsing the Command Line</a></h2>
<p><code>.z.x</code> and <code>.z.X</code> provide a way to view the options and arguments supplied at the command line. However, extracting the values manually from these strings can be cumbersome.</p>
<p>Fortunately, Q offers a more convenient way to parse the command line options.</p>
<h3 id="converting-to-a-dictionary-with-qopt"><a class="header" href="#converting-to-a-dictionary-with-qopt">Converting to a Dictionary with <code>.Q.opt</code></a></h3>
<p>In the following example, we pass a script file <code>test.q</code>, two custom options <code>-myOpt1</code> and <code>-myOpt2</code> with values <code>10</code> and <code>'Hello World'</code>, and the built-in <code>-p</code> option with a value of <code>5000</code>:</p>
<pre><code class="language-q">C:\&gt; q test.q -myOpt1 10 -p 5000 -myOpt2 'Hello World'
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q).z.x
"-myOpt1"
"10"
"-myOpt2"
"Hello World"
q).Q.opt .z.x
myOpt1| "10"
myOpt2| "Hello World"
</code></pre>
<p>Applying <code>.Q.opt</code> to <code>.z.x</code> converts the options into a dictionary, mapping the option names (as symbols) to their respective values (as strings).</p>
<p><code>.Q.opt</code> also works with <code>.z.X</code>, even when the first two items are the Q binary and a script file:</p>
<pre><code class="language-q">q).z.X
"C:\\q\\w64\\q.exe"
"test.q"
"-myOpt1"
"10"
"-p"
"5000"
"-myOpt2"
"Hello World"
q).Q.opt .z.X
myOpt1| "10"
p     | "5000"
myOpt2| "Hello World"
</code></pre>
<h3 id="casting-and-providing-defaults-with-qdef"><a class="header" href="#casting-and-providing-defaults-with-qdef">Casting and Providing Defaults with <code>.Q.def</code></a></h3>
<p><code>.Q.def</code> allows you to provide default values for command line options. It also casts the option values to the same type as the default.</p>
<p><code>.Q.def</code> takes two arguments:</p>
<ul>
<li>A dictionary mapping option names to their default values.</li>
<li>A dictionary mapping provided option names to their values (i.e., <code>.Q.opt .z.X</code>).</li>
</ul>
<h4 id="example-1-casting"><a class="header" href="#example-1-casting">Example 1: Casting</a></h4>
<pre><code class="language-q">q)show defaults:`myOpt1`myOpt2`p!(100f;`Nothing;1234)
myOpt1| 100f
myOpt2| `Nothing
p     | 1234
q).Q.def[defaults;.Q.opt .z.X]
myOpt1| 10f
myOpt2| `Hello World
p     | 5000
</code></pre>
<p>In this example, the value for <code>myOpt1</code> is cast to a float (<code>10f</code>) because the default value is a float. The value for <code>myOpt2</code> is cast to a symbol (<code> `Hello World</code>) since the default is a symbol.</p>
<h4 id="example-2-defaulting"><a class="header" href="#example-2-defaulting">Example 2: Defaulting</a></h4>
<p>In this example, we provide values for <code>myOpt2</code> and <code>p</code>, but omit <code>myOpt1</code>. The missing option uses the default:</p>
<pre><code class="language-q">C:\&gt; q test.q -p 5000 -myOpt2 'Hello World'
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)show defaults:`myOpt1`myOpt2`p!(100f;`Nothing;1234)
myOpt1| 100f
myOpt2| `Nothing
p     | 1234
q).Q.def[defaults;.Q.opt .z.X]
myOpt1| 100f
myOpt2| `Hello World
p     | 5000
</code></pre>
<p>Since <code>myOpt1</code> was not provided on the command line, <code>.Q.def</code> uses the default value <code>100f</code>.</p>
<h4 id="example-3-list-of-arguments"><a class="header" href="#example-3-list-of-arguments">Example 3: List of Arguments</a></h4>
<p><code>myOpt2</code> is cast to a symbol because its default value was a symbol (<code> `Nothing</code>). However, it would be better if it were a string since the user‚Äôs input might include spaces.</p>
<pre><code class="language-q">q)show defaults:`myOpt1`myOpt2`p!(100f;"Nothing";1234)
myOpt1| 100f
myOpt2| "Nothing"
p     | 1234
q)show args:.Q.def[defaults;.Q.opt .z.X]
myOpt1| 100f
myOpt2| ," "
p     | 5000
</code></pre>
<p>The value of <code>myOpt2</code> has been replaced with an enlisted null char.</p>
<p>When providing a default for a string type, we must ensure that the default value is enlisted so it is handled correctly by <code>.Q.def</code>:</p>
<pre><code class="language-q">q)show defaults:`myOpt1`myOpt2`p!(100f;enlist "Nothing";1234)
myOpt1| 100f
myOpt2| ,"Nothing"
p     | 1234
q).Q.def[defaults;.Q.opt .z.X]
myOpt1| 100f
myOpt2| ,"Hello World"
p     | 5000
</code></pre>
<p>This issue does not affect other list types, for example:</p>
<pre><code class="language-q">C:\&gt; q -longs 1 2 3 -syms abc xyz
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)show defaults:`longs`missingLongs`syms`missingSyms!(10 20 30;8 9;`123`789;`hey`ho)
longs       | 10 20 30
missingLongs| 8 9
syms        | `123`789
missingSyms | `hey`ho
q).Q.def[defaults;.Q.opt .z.X]
longs       | 1 2 3
missingLongs| 8 9
syms        | `abc`xyz
missingSyms | `hey`ho
</code></pre>
<p>However, if you want to default to a single value but expect a list from the user, you must ensure the default is enlisted:</p>
<pre><code class="language-q">C:\&gt; q -longs 1 2 3
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)show defaults:`longs`missingLongs!(100;10 20 30)
longs       | 100
missingLongs| 10 20 30
q).Q.def[defaults;.Q.opt .z.X]
longs       | 1
missingLongs| 10 20 30
</code></pre>
<p>The provided values <code>1 2 3</code> were truncated to just <code>1</code> because the default was not enlisted.</p>
<pre><code class="language-q">q)show defaults:`longs`missingLongs!(enlist 100;10 20 30)
longs       | ,100
missingLongs| 10 20 30
q).Q.def[defaults;.Q.opt .z.X]
longs       | 1  2  3
missingLongs| 10 20 30
</code></pre>
<h3 id="applying-defaults-to-built-in-options"><a class="header" href="#applying-defaults-to-built-in-options">Applying Defaults to Built-in Options</a></h3>
<p>In a previous example, we set <code>5000</code> as the default value for the <code>-p</code> option. If the value is not provided, we may specify a default, but it‚Äôs up to the user to actually apply these defaults:</p>
<pre><code class="language-q">C:\&gt; q
KDB+ 4.1 2024.03.12 Copyright (C) 1993-2024 Kx Systems
w64/ 8(24)core 32448MB ..

q)\p
0i
q)show defaults:enlist[`p]!enlist 5000
p| 5000
q).Q.def[defaults;.Q.opt .z.X]
p| 5000
q)\p
0i
q)"p ",string .Q.def[defaults;.Q.opt .z.X]`p
"p 5000"
q)system "p ",string .Q.def[defaults;.Q.opt .z.X]`p // Set the listening port
q)\p
5000i
</code></pre>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>Parsing and handling command-line options in Q can significantly enhance the flexibility and configurability of your scripts. By using the built-in functions <code>.z.x</code>, <code>.z.X</code>, <code>.Q.opt</code>, and <code>.Q.def</code>, you can easily access, process, and apply default values to both custom and built-in options. These tools allow you to convert command-line arguments into structured data like dictionaries, cast values to appropriate types, and handle multiple arguments efficiently.</p>
<p>Understanding these features not only improves the maintainability of your Q code but also allows you to build scripts that can adapt to various input configurations seamlessly. Whether you are working with custom options or using default values for built-in commands, Q provides the mechanisms needed to simplify these processes, making it easier to develop dynamic and reusable Q scripts.</p>
<p>Incorporating these best practices into your development workflow will help ensure that your Q scripts remain robust, adaptable, and user-friendly.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="an-introduction-to-interacting-with-rest-apis-in-qkdb"><a class="header" href="#an-introduction-to-interacting-with-rest-apis-in-qkdb">An Introduction to Interacting with REST APIs in Q/KDB+</a></h1>
<p><img src="images/rest_apis_introduction.png" title="Cover Image" alt="Cover Image"></p>
<p>In today‚Äôs interconnected world, many websites and services provide programmatic access to their data through REST APIs. REST (Representational State Transfer) APIs allow different systems to securely exchange data over the internet. The Q programming language includes built-in HTTP request capabilities and, in this blog, we‚Äôll explore how to interact with REST APIs using Q.</p>
<h2 id="http-get-via-qhg"><a class="header" href="#http-get-via-qhg">HTTP GET via <code>.Q.hg</code></a></h2>
<p>The <code>.Q.hg</code> function in Q is a powerful tool that allows you to perform HTTP GET requests directly from your Q session. By simply passing a URL to <code>.Q.hg</code>, you can retrieve raw data, such as the HTML of a webpage, which can then be processed or analysed.</p>
<pre><code class="language-q">q).Q.hg `:http://www.google.com
"&lt;!doctype html&gt;&lt;html itemscope=\"\" itemtype=\"http://schema.org/WebPage\" lang=\"en-GB\"&gt;&lt;head&gt;...
</code></pre>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p>HTTPS (Hypertext Transfer Protocol Secure) is an extension of HTTP that uses <a href="https://code.kx.com/q/kb/ssl/">SSL/TLS</a> protocols to encrypt data, ensuring secure communication between clients and servers. To make HTTPS requests in Q, your environment must be configured to support SSL/TLS. If this configuration is missing, Q will raise an error when attempting an HTTPS request.</p>
<pre><code class="language-q">q).Q.hg `:https://www.google.com
'conn. OS reports: The requested protocol has not been configured into the system, or no implementation for it exists.
  [0]  .Q.hg `:https://www.google.com
       ^
</code></pre>
<p>SSL verification can be bypassed by setting the <code>SSL_VERIFY_SERVER</code> environment variable to <code>NO</code>. This should only be used in trusted environments, as disabling SSL verification can expose your application to security risks.</p>
<h3 id="windows-command-prompt"><a class="header" href="#windows-command-prompt">Windows Command Prompt</a></h3>
<pre><code class="language-powershell">set "SSL_VERIFY_SERVER=NO" 
</code></pre>
<h3 id="linux--macos-terminal"><a class="header" href="#linux--macos-terminal">Linux &amp; macOS Terminal</a></h3>
<pre><code class="language-bash">export SSL_VERIFY_SERVER=NO
</code></pre>
<h3 id="example-in-q"><a class="header" href="#example-in-q">Example in Q</a></h3>
<p>Once the environment variable is set, you can verify it and perform an HTTPS request:</p>
<pre><code class="language-q">q)getenv `SSL_VERIFY_SERVER
"NO"

q).Q.hg `:https://www.google.com
"&lt;!doctype html&gt;&lt;html itemscope=\"\" itemtype=\"http://schema.org/WebPage\" lang=\"en-GB\"&gt;&lt;head&gt;...
</code></pre>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>JSON (JavaScript Object Notation) is a lightweight data interchange format widely used in REST APIs due to its simplicity and ease of parsing. In Q, JSON objects and arrays map naturally to dictionaries and tables, respectively, making it straightforward to work with API data.</p>
<h3 id="json-objects"><a class="header" href="#json-objects">JSON Objects</a></h3>
<p>JSON objects are structured as a collection of key-value pairs, which directly correspond to Q dictionaries. Each key is a string, and its associated value can be a string, number, array, object, or Boolean.</p>
<pre><code class="language-JSON">{
    "firstName": "John", 
    "lastName": "Smith"
}
</code></pre>
<p>In this example, <code>firstName</code> and <code>lastName</code> are keys, and <code>"John"</code> and <code>"Smith"</code> are their respective values.</p>
<h3 id="json-arrays"><a class="header" href="#json-arrays">JSON Arrays</a></h3>
<p>JSON arrays are ordered collections of values, which can include objects, similar to a list of dictionaries, i.e., a table, in Q.</p>
<pre><code class="language-JSON">[
    { "firstName": "John", "lastName": "Wick" },
    { "firstName": "Mary", "lastName": "Sue" }
]
</code></pre>
<p>In this example, the array contains two JSON objects, each representing a person with <code>firstName</code> and <code>lastName</code> fields.</p>
<h3 id="working-with-json-in-q"><a class="header" href="#working-with-json-in-q">Working with JSON in Q</a></h3>
<p>Q simplifies the process of decoding JSON data using the <code>.j.k</code> function. This function parses a JSON string into a corresponding Q data structure‚Äîdictionaries for objects and tables for arrays of objects.</p>
<h4 id="example-1-parsing-a-json-object"><a class="header" href="#example-1-parsing-a-json-object">Example 1: Parsing a JSON Object</a></h4>
<pre><code class="language-q">q).j.k "{ \"firstName\": \"John\", \"lastName\": \"Smith\" }"
firstName| "John"
lastName | "Smith"
</code></pre>
<p>Here, the JSON object is parsed into a Q dictionary with <code>firstName</code> and <code>lastName</code> as keys.</p>
<h4 id="example-2-parsing-a-json-array"><a class="header" href="#example-2-parsing-a-json-array">Example 2: Parsing a JSON Array</a></h4>
<pre><code class="language-q">q).j.k "[ { \"firstName\": \"John\", \"lastName\": \"Wick\" }, { \"firstName\": \"Mary\", \"lastName\": \"Sue\" } ]"
firstName lastName
------------------
"John"    "Wick"
"Mary"    "Sue"
</code></pre>
<p>This JSON array is parsed into a Q table, with <code>firstName</code> and <code>lastName</code> as column names.</p>
<p>JSON is a common format for data exchange in APIs, and Q‚Äôs built-in capabilities make it easy to decode and manipulate this data efficiently.</p>
<h2 id="a-real-example-using-the-cheapshark-api"><a class="header" href="#a-real-example-using-the-cheapshark-api">A Real Example: Using the <em>CheapShark</em> API</a></h2>
<p><em>CheapShark</em> is a website that aggregates the best deals on PC games from various popular stores like <em>Steam</em>, <em>Humble Bundle</em>, <em>Fanatical</em>, and more. It offers a free, easy-to-use REST API that does not require an authorisation key, making it an excellent resource for learning how to work with real-world APIs.</p>
<h3 id="understanding-the-api"><a class="header" href="#understanding-the-api">Understanding the API</a></h3>
<p>Most sites that provide a REST API will offer documentation to guide users on how to interact with their endpoints. The documentation for the <em>CheapShark</em> API can be found <a href="https://apidocs.cheapshark.com/">here</a>.</p>
<h3 id="making-api-calls"><a class="header" href="#making-api-calls">Making API Calls</a></h3>
<p>API calls typically begin with a base URL, which serves as the root address that you extend with specific endpoints to access different resources.</p>
<pre><code class="language-q">q)baseURL:`:https://www.cheapshark.com/api/1.0
</code></pre>
<p>In this example, <code>1.0</code> denotes the API version. API versions can change over time as the service evolves, so it‚Äôs essential to check the documentation for the correct version.</p>
<p>To request specific data, the base URL is extended with an endpoint. According to the <em>CheapShark</em> documentation, one available endpoint is <em>deals</em>, which provides information on current game deals.</p>
<h4 id="querying-the-deals-endpoint"><a class="header" href="#querying-the-deals-endpoint">Querying the Deals Endpoint</a></h4>
<p>The base URL can be extended with the <em>deals</em> endpoint to retrieve information about ongoing sales:</p>
<pre><code class="language-q">q).Q.dd[baseURL;`deals]
`:https://www.cheapshark.com/api/1.0/deals
</code></pre>
<p>The above code constructs the full URL to the deals endpoint. To fetch data from this endpoint, use the <code>.Q.hg</code> function to send an HTTP GET request and then parse the JSON response with <code>.j.k</code>:</p>
<pre><code class="language-q">q)deals:.j.k .Q.hg .Q.dd[baseURL;`deals]
</code></pre>
<p>This command retrieves and decodes the JSON response into a Q table. You can then inspect the data:</p>
<pre><code class="language-q">q)type deals
98h
q)count deals
60
q)first deals
internalName      | "METAMORPHOSIS"
title             | "Metamorphosis"
metacriticLink    | "/game/metamorphosis/"
dealID            | "oML4oLCz0hlxkKKQpDwVSBwm6NNQUvEBx1igr7uOgWw%3D"
storeID           | ,"1"
gameID            | "218750"
salePrice         | "10.50"
normalPrice       | "34.98"
isOnSale          | ,"1"
savings           | "69.982847"
metacriticScore   | ,"0"
steamRatingText   | "Very Positive"
steamRatingPercent| "83"
steamRatingCount  | "405"
steamAppID        | "1025410"
releaseDate       | 1.724976e+09
lastChange        | 1.724246e+09
dealRating        | "10.0"
thumb             | "https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1025410/c..
</code></pre>
<p>In the <code>deals</code> table, each row corresponds to a game deal, with fields like <code>title</code>, <code>salePrice</code>, and <code>normalPrice</code> providing details about the game and its discount.</p>
<p>This example demonstrates how to use Q to interact with a real REST API, retrieving and processing JSON data effectively.</p>
<h3 id="schema-mapping"><a class="header" href="#schema-mapping">Schema Mapping</a></h3>
<p>When working with external data, especially from APIs, the incoming data might not always match the desired format or types. In such cases, it‚Äôs essential to ‚Äúclean‚Äù the data‚Äîformatting, casting types, and removing erroneous rows to ensure consistency and usability. A good approach is to define a schema that outlines the expected structure and data types, which can then be applied to the incoming data.</p>
<h4 id="defining-the-schema"><a class="header" href="#defining-the-schema">Defining the Schema</a></h4>
<p>One effective way to define and manage this schema is by using a CSV file. The schema can specify the column names, data types, whether the columns are required, and any additional attributes.</p>
<pre><code class="language-CSV">column,origColumn,ty,required,enabled,isKey,attrib,description
internalName,internalName,s,0,0,0,,Game title used internally by CheapShark
title,title,*,1,1,0,,Game title
metacriticLink,metacriticLink,*,0,0,0,,Link to game page on Metacritic 
dealID,dealID,*,1,1,1,u,Deal identifier
storeID,storeID,j,1,1,0,,Game store identifier
gameID,gameID,j,1,1,0,,Game identifier
salePrice,salePrice,f,1,1,0,,Deal/reduced price of game (USD)
normalPrice,normalPrice,f,1,1,0,,Usual/full price of game (USD)
isOnSale,isOnSale,b,0,1,0,,True if game is currently on sale
savings,savings,f,0,1,0,,Percent saved on sale price compared to normal price  
metacriticScore,metacriticScore,j,1,1,0,,Score on Metacritic (0-100)
steamRatingText,steamRatingText,*,1,1,0,,Rating on Steam
steamRatingPercent,steamRatingPercent,j,1,1,0,,Percentage rating on Steam (0-100)
steamRatingCount,steamRatingCount,j,1,1,0,,Number of ratings given on Steam
steamAppID,steamAppID,j,0,0,0,,Application identifier on Steam
releaseDate,releaseDate,j,1,1,0,,Date game was released
lastChange,lastChange,j,0,0,0,,Date of last change made to game
dealRating,dealRating,f,1,1,0,,CheapShark deal rating (0.0-10.0)
thumb,thumb,*,0,0,0,,Link to thumbnail image
</code></pre>
<h4 id="loading-the-schema"><a class="header" href="#loading-the-schema">Loading the Schema</a></h4>
<p>Q provides a straightforward way to load a CSV file into a table. For our schema configuration, we can use the following command to load the schema from a CSV file:</p>
<pre><code class="language-q">q)show schema:("sscbbbs*";enlist ",") 0: `:schema/deals.csv
column             origColumn         ty required enabled isKey attrib description               ..
-------------------------------------------------------------------------------------------------..
internalName       internalName       s  0        0       0            "Game title used internall..
title              title              *  1        1       0            "Game title"              ..
metacriticLink     metacriticLink     *  0        0       0            "Link to game page on Meta..
dealID             dealID             *  1        1       1     u      "Deal identifier"         ..
storeID            storeID            j  1        1       0            "Game store identifier"   ..
gameID             gameID             j  1        1       0            "Game identifier"         ..
..
</code></pre>
<p>This command reads the <code>schema/deals.csv</code> file and displays its contents as a table. Each row in the schema configuration corresponds to a column in the deals table.</p>
<ul>
<li><code>column</code>: The desired name for the column in Q.</li>
<li><code>origColumn</code>: The original column name from the external source.</li>
<li><code>ty</code>: The expected data type for the column.</li>
<li><code>required</code>: A flag indicating whether the column is mandatory.</li>
<li><code>enabled</code>: A flag indicating whether the column should be included in the final table.</li>
<li><code>isKey</code>: A flag to indicate if the column should be used as a key.</li>
<li><code>attrib</code>: Any attributes that should be applied to the column (e.g., <code>u</code> for unique).</li>
<li><code>description</code>: A brief explanation of what the column represents.</li>
</ul>
<p>This schema setup provides a clear structure for managing and validating the data we receive from the deals API.</p>
<h4 id="the-applyschema-function"><a class="header" href="#the-applyschema-function">The <code>applySchema</code> Function</a></h4>
<p>To ensure the <code>deals</code> table conforms to the expected schema, the following function is defined:</p>
<pre><code class="language-q">// Ensure a table conforms to the given schema
applySchema:{[schema;tab]
    // Select only enabled columns from the schema - useful for excluding unnecessary columns
    schema:select from schema where enabled;
    
    // Ensure all required columns are present in the data
    reqCols:exec origColumn from schema where required;
    if[not all b:reqCols in cols tab; 
        msg:"Required columns missing: ",", " sv string reqCols where not b;
        -1 msg;
        'msg
    ];
    
    // Keep only columns that are both expected and received
    tab:#[;tab] cols[tab] inter exec origColumn from schema;

    // Rename columns to conform to Q's naming conventions
    tab:xcol[;tab] exec origColumn!column from schema;
    
    // Cast columns to their correct data types
    tab:cast[cols tab;exec (column!ty) cols tab from schema;tab];
    
    // Apply attributes to the appropriate columns
    tab:applyAttr[;tab] exec column!attrib from schema where not null attrib;
    
    // Set the specified columns as the key(s) of the table
    tab:xkey[;tab] exec column from schema where isKey;

    // Return the cleaned and formatted table
    tab
 }
</code></pre>
<h5 id="explanation-of-the-applyschema-function"><a class="header" href="#explanation-of-the-applyschema-function">Explanation of the <code>applySchema</code> Function:</a></h5>
<ol>
<li>
<p><strong>Selecting Enabled Columns</strong>: The schema may include columns that are not needed for the current operation. This step filters out any columns that are not marked as enabled in the schema.</p>
</li>
<li>
<p><strong>Checking for Required Columns</strong>: Ensures that all columns marked as required in the schema are present in the incoming data. If any required columns are missing, the function throws an error with a descriptive message.</p>
</li>
<li>
<p><strong>Filtering Received Columns</strong>: The function retains only those columns in the incoming data that are both expected (as per the schema) and present in the received data. This helps to discard any extraneous columns.</p>
</li>
<li>
<p><strong>Renaming Columns</strong>: Column names are often inconsistent with Q‚Äôs conventions when received from external sources (not the case with <em>CheapShark</em> data). This step renames the columns to conform to Q‚Äôs naming conventions, which are specified in the schema.</p>
</li>
<li>
<p><strong>Casting Columns to Correct Data Types</strong>: The function casts each column to its appropriate data type as specified in the schema. This is important for ensuring that the data can be accurately and efficiently processed.</p>
</li>
<li>
<p><strong>Applying Attributes</strong>: Certain attributes, like <code>u</code> (unique), may need to be applied to specific columns. This step applies those attributes based on the schema configuration.</p>
</li>
<li>
<p><strong>Setting the Table Key</strong>: The function sets the key for the table using the columns marked as <code>isKey</code> in the schema. This is crucial for operations that depend on uniquely identifying rows in the table.</p>
</li>
<li>
<p><strong>Returning the Cleaned Table</strong>: Finally, the function returns the table with all the above transformations applied, ensuring it is in a clean, consistent, and usable format.</p>
</li>
</ol>
<h4 id="helper-functions-used-in-applyschema"><a class="header" href="#helper-functions-used-in-applyschema">Helper Functions Used in <code>applySchema</code></a></h4>
<h5 id="column-type-casting"><a class="header" href="#column-type-casting">Column Type Casting</a></h5>
<p>The <code>applySchema</code> function relies on the following helper function to cast columns to their correct data types:</p>
<pre><code class="language-q">// Cast column types in tab
cast:{[columns;ty;tab]
    col2Ty:columns!ty;
    col2Ty,:exec c!upper col2Ty c from meta tab where t="C";
    col2Ty:{($),x,y}'[col2Ty;key col2Ty];
    ![tab;();0b;col2Ty]
 }
</code></pre>
<p>Explanation:</p>
<ul>
<li>The <code>cast</code> function creates a mapping (<code>col2Ty</code>) between column names and their intended types.</li>
<li>For columns that are received as strings, the function checks their actual data type and applies the appropriate casting by converting the type character to its uppercase form.</li>
<li>The function then generates a list of applicable casting functions and applies these to the corresponding columns in the table. This ensures that each column in the table is correctly typed according to the schema.</li>
</ul>
<h5 id="applying-attributes-to-columns"><a class="header" href="#applying-attributes-to-columns">Applying Attributes to Columns</a></h5>
<p>Another important aspect of schema application is setting the correct attributes for columns. The following helper function is used for this purpose:</p>
<pre><code class="language-q">// Apply attributes to columns
applyAttr:{[col2Attr;tab] ![tab;();0b;] {(#;enlist x;y)}'[col2Attr;key col2Attr]}
</code></pre>
<p>Explanation:</p>
<ul>
<li>The <code>applyAttr</code> function creates a mapping (<code>col2Attr</code>) between column names and their associated attributes.</li>
<li>In the example provided, the mapping could look like <code>dealID | `u</code>, which means that the <code>u</code> (unique) attribute should be applied to the <code>dealID</code> column within the table.</li>
</ul>
<h4 id="applying-the-schema"><a class="header" href="#applying-the-schema">Applying the Schema</a></h4>
<p>Now that we‚Äôve defined the <code>applySchema</code> function, let‚Äôs put it into action by applying the schema to the <code>deals</code> table. This will ensure that the table conforms to the expected structure, with the appropriate data types, column names, and attributes as defined in the schema.</p>
<pre><code class="language-q">q)deals:applySchema[schema;deals]
</code></pre>
<p>After applying the schema, we can inspect the first row of the <code>deals</code> table to verify that the data has been correctly formatted (note that <code>dealID</code> is a key column and is not shown when the <code>first</code> keyword is applied):</p>
<pre><code class="language-q">q)first deals
title             | "Metamorphosis"
storeID           | 1
gameID            | 218750
salePrice         | 10.5
normalPrice       | 34.98
isOnSale          | 1b
savings           | 69.98285
metacriticScore   | 0
steamRatingText   | "Very Positive"
steamRatingPercent| 83
steamRatingCount  | 406
releaseDate       | 1724976000
dealRating        | 10f
</code></pre>
<h4 id="converting-unix-epoch-timestamps-to-q-timestamps"><a class="header" href="#converting-unix-epoch-timestamps-to-q-timestamps">Converting Unix Epoch Timestamps to Q Timestamps</a></h4>
<p>In the <code>deals</code> table, the <code>releaseDate</code> column is currently a long integer. According to the <em>CheapShark</em> documentation, this column represents a Unix Epoch timestamp, which is the number of seconds elapsed since <code>1970.01.01</code>.</p>
<p>To make this data more usable, we need to convert these Unix Epoch timestamps into Q timestamps, which are based on the number of nanoseconds since <code>2000.01.01</code>.</p>
<p>Q provides a straightforward way to perform this conversion, as shown below:</p>
<pre><code class="language-q">q)"P"$string 1724976000
2024.08.30D00:00:00.000000000
</code></pre>
<p>The <code>"P"$</code> operation converts a string representation of the Unix Epoch timestamp into a Q timestamp.</p>
<p>This conversion isn‚Äôt handled within the <code>applySchema</code> function because the <code>releaseDate</code> column is received as a float. To correctly convert the Unix Epoch timestamp to a Q timestamp, the value must first be cast to a long, then converted from a string representation of that long integer.</p>
<p>We can automate this process with a helper function:</p>
<pre><code class="language-q">// Convert Unix Epoch timestamps to Q timestamps
convertEpoch:{[epochCols;tab]
    ![tab;();0b;] epochCols!("P"$string@),/:epochCols:(epochCols,()) inter cols tab
 }
</code></pre>
<p>This function:</p>
<ul>
<li>Takes as input the names of the columns (<code>epochCols</code>) that store Unix Epoch timestamps and the table (<code>tab</code>) containing these columns.</li>
<li>Converts the values in these columns from Unix Epoch timestamps to Q timestamps.</li>
</ul>
<p>Now, let‚Äôs apply this function to the <code>deals</code> table:</p>
<pre><code class="language-q">q)deals:convertEpoch[`releaseDate;deals]
q)first deals
title             | "Metamorphosis"
storeID           | 1
gameID            | 218750
salePrice         | 10.5
normalPrice       | 34.98
isOnSale          | 1b
savings           | 69.98285
metacriticScore   | 0
steamRatingText   | "Very Positive"
steamRatingPercent| 83
steamRatingCount  | 406
releaseDate       | 2024.08.30D00:00:00.000000000
dealRating        | 10f
</code></pre>
<h3 id="example-queries"><a class="header" href="#example-queries">Example Queries</a></h3>
<p>With the formatted <code>deals</code> table, you can now easily extract valuable insights. Below are some examples of useful queries you can perform:</p>
<h4 id="find-games-that-are-free"><a class="header" href="#find-games-that-are-free">Find Games That Are Free</a></h4>
<p>To identify which games are currently free, you can run the following query:</p>
<pre><code class="language-q">q)select from deals where salePrice=0
dealID                                                  | title                        storeID gameID salePrice normalPrice isOnSale savings ..
--------------------------------------------------------| -----------------------------------------------------------------------------------..
"hnqzhI6mSozJT13ntObN06QUeuLOaArkDyEu%2BiBplK4%3D"      | "Wild Card Football"         25      269270 0         29.99       1        100     ..
"l%2BZiBW2Mu0W4B%2BipW%2FpUJ%2BAn218BfeYzAKecxjhUGO0%3D"| "Fallout Classic Collection" 25      120604 0         19.99       1        100     ..
</code></pre>
<p>This query filters the <code>deals</code> table to return only the rows where the <code>salePrice</code> is 0, showing which games are currently available for free.</p>
<h4 id="sort-games-by-metacritic-rating"><a class="header" href="#sort-games-by-metacritic-rating">Sort Games by Metacritic Rating</a></h4>
<p>If you want to see the games sorted by their <em>Metacritic</em> score, with the highest-rated games first, use this query:</p>
<pre><code class="language-q">q)`metacriticScore xdesc deals
dealID                                                | title                                        storeID gameID salePrice normalPrice ..
------------------------------------------------------| ----------------------------------------------------------------------------------..
"OGCfBOUZvvl8JPIWeBbYeWvtFw%2BBEy9WgFdO7pM999Q%3D"    | "Deus Ex: Human Revolution - Director's Cut" 2       102249 2.55      19.99       ..
"h1pI0RMkHs6sjcjboS%2FvYhEytAI7XAat%2BSiXmP%2FL0OA%3D"| "Metro 2033 Redux"                           25      109746 1.99      19.99       ..
"Ersqftfht15yRvVi%2BQtYqzHcXHuORprGmyDT0uvo5zc%3D"    | "Homeworld Remastered Collection"            1       141243 3.49      34.99       ..
"3vW2Xy%2BiwEVnQOoN7KB2RlEAYz1%2FqK0IheNSCUA3g64%3D"  | "Shadow Tactics: Blades of the Shogun"       25      158443 3.99      39.99       ..
"chTGFNtThpFwF7mhwKUFmuh101BeXYsHrDyGbnwDLw0%3D"      | "Deus Ex: Mankind Divided"                   2       143165 3.83      29.99       ..
..
</code></pre>
<p>This query sorts the deals table by the <code>metacriticScore</code> in descending order, allowing you to quickly identify the top-rated games.</p>
<h4 id="identify-games-with-high-discounts"><a class="header" href="#identify-games-with-high-discounts">Identify Games with High Discounts</a></h4>
<p>To find games where you can save more than 90%, use the following query:</p>
<pre><code class="language-q">q)select from deals where savings&gt;90
dealID                                                    | title                                    storeID gameID salePrice normalPrice ..
----------------------------------------------------------| ------------------------------------------------------------------------------..
"hnqzhI6mSozJT13ntObN06QUeuLOaArkDyEu%2BiBplK4%3D"        | "Wild Card Football"                     25      269270 0         29.99       ..
"syEZpIi1rsbwUJ1YU1OKiLx1O3gN1Ax0ei1ANNvNsqI%3D"          | "NHRA: Speed for All - Ultimate Edition" 25      277998 7.99      79.99       ..
"ut1jqPlDrAYP%2BfA%2BWwDTf7DX%2B69aQWre5UlfuOLtLwE%3D"    | "Strange Brigade - Deluxe Edition"       2       186386 6         79.99       ..
"Kp3%2BW%2B6AtA%2FpJ5TzS9HpxUmOT0xZIWoiB%2BEgs%2F9JzpU%3D"| "Sniper Elite 4 Deluxe Edition"          2       158734 6.75      89.99       ..
"l%2BZiBW2Mu0W4B%2BipW%2FpUJ%2BAn218BfeYzAKecxjhUGO0%3D"  | "Fallout Classic Collection"             25      120604 0         19.99       ..
..
</code></pre>
<p>This query selects games where the savings column shows a discount greater than 90%, helping you to spot the best deals available.</p>
<h3 id="filtered-queries"><a class="header" href="#filtered-queries">Filtered Queries</a></h3>
<p>Instead of retrieving all deals from the API (which may be constrained by page size), you can apply filters directly in your API queries to target specific data.</p>
<h4 id="building-the-filter"><a class="header" href="#building-the-filter">Building the Filter</a></h4>
<p>First, we‚Äôll create a dictionary that maps filter names to their respective values. In this example, we want to retrieve all deals from <code>storeID = 1</code> with a <code>salePrice</code> less than or equal to $10:</p>
<pre><code class="language-q">q)flts:`storeID`upperPrice!("1";"10")
</code></pre>
<h4 id="composing-the-filter-string"><a class="header" href="#composing-the-filter-string">Composing the Filter String</a></h4>
<p>Next, we‚Äôll use a helper function to convert this dictionary into a filter string that can be appended to the API URL:</p>
<pre><code class="language-q">q)buildFltStr:"&amp;" sv value {[flts] {x,"=",y}'[string key flts;flts]}@
</code></pre>
<p>This function generates an <code>&amp;</code>-delimited string of <code>key=value</code> pairs from the dictionary:</p>
<pre><code class="language-q">q)buildFltStr flts
"storeID=1&amp;upperPrice=10"
</code></pre>
<h4 id="constructing-the-api-url"><a class="header" href="#constructing-the-api-url">Constructing the API URL</a></h4>
<p>We can now construct the full API URL with the filter string included:</p>
<pre><code class="language-q">q).Q.dd[baseURL;] `$"deals?",buildFltStr flts
`:https://www.cheapshark.com/api/1.0/deals?storeID=1&amp;upperPrice=10
</code></pre>
<h4 id="fetching-filtered-data"><a class="header" href="#fetching-filtered-data">Fetching Filtered Data</a></h4>
<p>Let‚Äôs call the API using the constructed URL to retrieve the filtered deals:</p>
<pre><code class="language-q">q)filteredDeals:.j.k .Q.hg .Q.dd[baseURL;] `$"deals?",buildFltStr flts
q)first filteredDeals
internalName  | "HOMEWORLDREMASTEREDCOLLECTION"
title         | "Homeworld Remastered Collection"
metacriticLink| "/game/homeworld-remastered-collection/"
dealID        | "Ersqftfht15yRvVi%2BQtYqzHcXHuORprGmyDT0uvo5zc%3D"
storeID       | ,"1"
gameID        | "141243"
salePrice     | "3.49"
..
</code></pre>
<p>Since this query still uses the deals API endpoint, the data structure returned follows the same schema as before.</p>
<h4 id="applying-the-schema-and-converting-timestamps"><a class="header" href="#applying-the-schema-and-converting-timestamps">Applying the Schema and Converting Timestamps</a></h4>
<p>Finally, we‚Äôll apply the schema and convert any Unix Epoch timestamps in the retrieved data:</p>
<pre><code class="language-q">q)filteredDeals:applySchema[schema;filteredDeals]
q)filteredDeals:convertEpoch[`releaseDate;filteredDeals]
q)first filteredDeals
title      | "Homeworld Remastered Collection"
storeID    | 1
gameID     | 141243
salePrice  | 3.49
normalPrice| 34.99
isOnSale   | 1b
savings    | 90.02572
..
</code></pre>
<h2 id="response-header"><a class="header" href="#response-header">Response Header</a></h2>
<p>When making HTTP requests, responses include not only the requested content (like the deals we‚Äôve seen) but also a header. Headers can contain valuable information, such as the status of the call (e.g., OK, Not Found) and other metadata.</p>
<h3 id="extracting-the-response-header"><a class="header" href="#extracting-the-response-header">Extracting the Response Header</a></h3>
<p>The utility function <code>.Q.hg</code> simplifies our lives by focusing on the content we need and hiding the header. However, there are cases where the header information is crucial. For example, the <em>CheapShark</em> API returns only up to 60 deals per page by default. To retrieve more data, you‚Äôll need to know how many pages of deals exist, which is indicated by the <code>x-total-page-count</code> header element.</p>
<h4 id="how-to-access-the-header"><a class="header" href="#how-to-access-the-header">How to Access the Header</a></h4>
<p>To access the header, we can bypass <code>.Q.hg</code> and use the underlying function <code>.Q.hmb</code> directly. Here‚Äôs a quick look at the definition of <code>.Q.hg</code>:</p>
<pre><code class="language-q">q).Q.hg
k){hmb[x;`GET;()]1}
</code></pre>
<p>The function <code>.Q.hg</code> calls <code>.Q.hmb</code>, indexing the second item in the result, which is the content of the response. To access the header, we‚Äôll need to capture the first item returned by <code>.Q.hmb</code>.</p>
<p>Let‚Äôs examine what <code>.Q.hmb</code> returns:</p>
<pre><code class="language-q">q)show res:.Q.hmb[;`GET;()] .Q.dd[baseURL;`deals]
"HTTP/1.1 200 OK\r\ndate: Tue, 03 Sep 2024 14:48:26 GMT\r\ncontent-type: application/json\r\ncont..
"[{\"internalName\":\"METAMORPHOSIS\",\"title\":\"Metamorphosis\",\"metacriticLink\":\"\\/game\\/..
</code></pre>
<p>The first item in <code>res</code> is the HTTP header, and the second item is the familiar JSON content. To extract individual elements from the header, we can split the string using <code>"\r\n"</code>:</p>
<pre><code class="language-q">q)show res:"\r\n" vs first res
"HTTP/1.1 200 OK"
"date: Tue, 03 Sep 2024 14:50:13 GMT"
"content-type: application/json"
"content-length: 8548"
"connection: close"
"cf-ray: 8bd68d08e961cca9-MAN"
"cf-cache-status: HIT"
..
</code></pre>
<h4 id="filtering-and-formatting-header-elements"><a class="header" href="#filtering-and-formatting-header-elements">Filtering and Formatting Header Elements</a></h4>
<p>To clean up the header, we remove any empty elements:</p>
<pre><code class="language-q">q)res@:where 0&lt;count each res
</code></pre>
<p>The first element in the header is the response status, which we can handle separately:</p>
<pre><code class="language-q">q)show header:enlist[`status]!enlist first res
status| "HTTP/1.1 200 OK"
</code></pre>
<p>For the remaining elements, we split them into <code>key: value</code> pairs:</p>
<pre><code class="language-q">q)x:first 1_res
q)(0,x?":") cut x
"date"
": Tue, 03 Sep 2024 14:51:39 GMT"
</code></pre>
<p>The key should be converted to a symbol and the value should have the leading <code>":"</code> removed along with any other leading whitespace:</p>
<pre><code class="language-q">q)(`$;ltrim 1_)@'(0,x?":") cut x
`date
"Tue, 03 Sep 2024 14:51:39 GMT"
</code></pre>
<p>We can apply this operation to all elements:</p>
<pre><code class="language-q">q){(`$;ltrim 1_)@'(0,x?":") cut x} each 1_res
`date            "Tue, 03 Sep 2024 14:51:39 GMT"
`content-type    "application/json"             
`content-length  "8548"                         
`connection      "close"                        
`cf-ray          "8bd68f23fef1b3e7-MAN"         
`cf-cache-status "HIT"                     
..
</code></pre>
<p>Then, convert the result into a Q dictionary:</p>
<pre><code class="language-q">q)(!). flip {(`$;ltrim 1_)@'(0,x?":") cut x} each 1_res
date           | "Tue, 03 Sep 2024 14:51:39 GMT"
content-type   | "application/json"
content-length | "8548"
connection     | "close"
cf-ray         | "8bd68f23fef1b3e7-MAN"
cf-cache-status| "HIT"
..
</code></pre>
<p>Finally, we can merge this with the header status:</p>
<pre><code class="language-q">q)show header,:(!). flip {(`$;ltrim 1_)@'(0,x?":") cut x} each 1_res
status         | "HTTP/1.1 200 OK"
date           | "Tue, 03 Sep 2024 14:51:39 GMT"
content-type   | "application/json"
content-length | "8548"
connection     | "close"
cf-ray         | "8bd68f23fef1b3e7-MAN"
cf-cache-status| "HIT"
..
</code></pre>
<h4 id="wrapping-it-up-in-a-function"><a class="header" href="#wrapping-it-up-in-a-function">Wrapping It Up in a Function</a></h4>
<p>For convenience, let‚Äôs encapsulate these steps in a function:</p>
<pre><code class="language-q">hg:{[url]
    r:.Q.hmb[url;`GET;()];
    h@:where 0&lt;count each h:"\r\n" vs first r;
    header:enlist[`status]!enlist first h;
    header,:(!). flip {(`$;ltrim 1_)@'(0,x?":") cut x} each 1_h;
    `header`content!(header;last r)
 }
</code></pre>
<h4 id="using-the-function"><a class="header" href="#using-the-function">Using the Function</a></h4>
<p>Now, we can use this function to extract the <code>x-total-page-count</code> from the header:</p>
<pre><code class="language-q">q)res:hg .Q.dd[baseURL;`deals]
q)show pageCount:"J"$res[`header]`$"x-total-page-count"
50
</code></pre>
<p>This initial query retrieves the first page of deals and the total number of pages. The content can be stored in a variable:</p>
<pre><code class="language-q">q)deals:.j.k res`content
</code></pre>
<p>For subsequent queries, we can revert to using <code>.Q.hg</code> and apply the <a href="#filtered-queries">filtered query</a> approach:</p>
<pre><code class="language-q">q)queryPage:.j.k .Q.hg .Q.dd[baseURL;] `$"deals?",buildFltStr enlist[`pageNumber]!enlist string@
q)queryPage 25 // Get 26th page (page numbering starts at 0)
internalName                             title                                             ..
-------------------------------------------------------------------------------------------..
"THETOWNOFLIGHT"                         "The Town Of Light"                               ..
"MXGP2021THEOFFICIALMOTOCROSSVIDEOGAME"  "MXGP 2021 - The Official Motocross Videogame"    ..
"KINGSBOUNTYIIDUKESEDITION"              "Kings Bounty II - Dukes Edition"                 ..
"NINOKUNIWRATHOFTHEWHITEWITCHREMASTERED" "Ni no Kuni: Wrath of the White Witch Remastered" ..
"SIDMEIERSCIVILIZATIONVIANTHOLOGY"       "Sid Meiers Civilization VI Anthology"            ..
..
</code></pre>
<p>To retrieve all pages, apply <code>queryPage</code> across the range of available pages (note that this may take some time):</p>
<pre><code class="language-q">q)pages:queryPage each 1+til pageCount
q)count pages
50
</code></pre>
<p>Finally, combine all pages into a single <code>deals</code> table by using <code>raze</code>:</p>
<pre><code class="language-q">q)deals,:raze pages
q)deals:applySchema[schema;deals]
q)deals:convertEpoch[`releaseDate;deals]
q)count deals
3060
</code></pre>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>Integrating external APIs with Q/KDB+ can significantly enhance the data capabilities of your applications, particularly when dealing with large datasets or dynamic content. In this blog, we‚Äôve explored how to interact with the <em>CheapShark</em> API, covering everything from basic API requests to more advanced topics like filtering queries, handling paginated data, and extracting valuable information from HTTP response headers.</p>
<p>By understanding these techniques, you can efficiently pull in and manipulate external data within your Q/KDB+ environment, opening up new possibilities for data analysis, application development, and real-time decision-making. Whether you‚Äôre querying for specific information or managing large datasets across multiple pages, these tools provide the flexibility needed to handle a wide range of scenarios.</p>
<p>With the knowledge from this guide, you should be well-equipped to integrate other APIs into your Q/KDB+ workflows, making your data processes even more powerful and versatile.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-little-q-keywords-that-could"><a class="header" href="#the-little-q-keywords-that-could">The Little Q Keywords That Could</a></h1>
<p><img src="images/little_q_keywords_that_could.png" title="Cover Image" alt="Cover Image"></p>
<p>In programming, keywords are predefined words with special meanings that form part of a language‚Äôs syntax. The Q programming language is rich with keywords, many of which were introduced to improve the readability of its predecessor, K4, by ‚Äúwordifying‚Äù many primitive operations. In this blog, we‚Äôll explore some of Q‚Äôs lesser-known or underutilised keywords that can be quite powerful when used effectively. We‚Äôll also examine a few keywords whose usefulness might be questionable.</p>
<h2 id="csv"><a class="header" href="#csv"><code>csv</code></a></h2>
<p>The <code>csv</code> keyword is a synonym for <code>","</code>, often used to represent a comma delimiter.</p>
<p><strong>Example Usage</strong></p>
<p><code>csv</code> is primarily used when specifying a delimiter for preparing or saving text data:</p>
<pre><code class="language-q">q)csv 0: ([] a:1 2 3; b:`a`b`c)
"a,b"
"1,a"
"2,b"
"3,c"

q)"," 0: ([] a:1 2 3; b:`a`b`c)
"a,b"
"1,a"
"2,b"
"3,c"
</code></pre>
<p>In the past, <code>csv</code> was particularly useful for working with comma-separated values (CSV) files. However, other delimited file formats have become popular, and it‚Äôs now common to use different delimiters when preparing or saving text data:</p>
<pre><code class="language-q">q)"|" 0: ([] a:1 2 3; b:`a`b`c)
"a|b"
"1|a"
"2|b"
"3|c"
</code></pre>
<p>Given this shift, <code>csv</code> is less useful than it once was. To maintain consistency, especially when using different delimiters, one should prefer to specify <code>","</code> explicitly.</p>
<h2 id="dsave"><a class="header" href="#dsave"><code>dsave</code></a></h2>
<p>Introduced in version 3.2, <code>dsave</code> is a convenient keyword used to write global tables to disk as splayed, enumerated, indexed KDB+ tables. It simplifies the process of saving data, especially when dealing with partitions.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">x dsave y
</code></pre>
<ul>
<li><code>x</code> : The save path as a file symbol (atom or vector).</li>
<li><code>y</code> : One or more table names as a symbol (atom or vector).</li>
</ul>
<p><strong>Example Usage</strong></p>
<p>In a fresh Q session, let‚Äôs define simple <code>trade</code> and <code>quote</code> tables:</p>
<pre><code class="language-q">q)trade:`sym xasc flip `sym`price`qty!5?/:(`3;100f;100)
q)quote:`sym xasc flip `sym`ask`bid!10?/:(distinct trade`sym;100f;100f)
</code></pre>
<p>You can save these tables to disk using <code>dsave</code>:</p>
<pre><code class="language-q">q)`:db1 dsave `trade`quote
`trade`quote
</code></pre>
<p>The command above creates a new root directory named <em>db1</em>. Within this directory, two subdirectories, <em>trade</em> and <em>quote</em>, are created for the respective tables. Additionally, <code>dsave</code> automatically enumerates any symbol columns in the tables, resulting in the creation of a sym file under the root directory (e.g., <code>db1/sym</code>).</p>
<p><code>dsave</code> will apply the <em>parted</em> attribute to the first column of the saved tables (<code>sym</code> in this case).</p>
<pre><code class="language-q">q)\l db1 // Load db1
::

q)meta trade
c    | t f a
-----| -----
sym  | s   p
price| f    
qty  | j 

q)meta quote
c  | t f a
---| -----
sym| s   p
ask| f    
bid| f    
</code></pre>
<p>You can also save to a specific partition by providing a two-item list as the left argument. In a fresh Q session, we define the <code>trade</code> and <code>quote</code> tables as before and then save them to a partition:</p>
<pre><code class="language-q">q)`:db2`2024.01.17 dsave `trade`quote
`trade`quote
</code></pre>
<p><strong>Comparison: <code>dsave</code> vs <code>.Q.en</code> &amp; <code>.Q.dpft</code></strong></p>
<p>While similar results can be achieved using <code>set</code> combined with <code>.Q.en</code>, or <code>.Q.dpft</code>, <code>dsave</code> offers a simpler and more direct approach.</p>
<p>Using <code>set</code> and <code>.Q.en</code> (fresh Q session):</p>
<pre><code class="language-q">q)`:db3/trade/ set .Q.en[`:db3;update `p#sym from trade]
`:db3/trade/

q)`:db3/quote/ set .Q.en[`:db3;update `p#sym from quote]
`:db3/quote/
</code></pre>
<p>Using <code>.Q.dpft</code> (fresh Q session):</p>
<pre><code class="language-q">q).Q.dpft[`:db4;2024.01.17;`sym;] each `trade`quote
`trade`quote
</code></pre>
<p><code>dsave</code> streamlines this process by combining these steps into a single, more intuitive operation.</p>
<h2 id="next"><a class="header" href="#next"><code>next</code></a></h2>
<p>The <code>next</code> keyword retrieves the next item in a list, returning null for the last item since it has no successor.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">next x
</code></pre>
<ul>
<li><code>x</code> : A list from which to retrieve the next items.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)next 10 20 30
20 30 0N
</code></pre>
<p>For mixed lists, the last item is an empty list of the same type as the first item:</p>
<pre><code class="language-q">q)next (10 20 30f;"hello";`blah)
"hello"
`blah
`float$()
</code></pre>
<p><code>next</code> is particularly useful when dealing with temporal types:</p>
<pre><code class="language-q">q)quote:([] sym:6#`a`b; time:00:01:00.000+"j"$1e3*0 0 17 42 68 112)

q)update next[time]-time by sym from quote // Duration of a quote
sym time
----------------
a   00:00:17.000
b   00:00:42.000
a   00:00:51.000
b   00:01:10.000
a
b
</code></pre>
<p><strong>Implementation</strong></p>
<p>Conceptually, <code>next</code> performs the following operation:</p>
<pre><code class="language-q">1_x,enlist x 0N
</code></pre>
<h2 id="prev"><a class="header" href="#prev"><code>prev</code></a></h2>
<p>The <code>prev</code> keyword retrieves the previous item in a list, returning null for the first item since it has no predecessor.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">prev x
</code></pre>
<ul>
<li><code>x</code> : A list from which to retrieve the previous items.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)prev 10 20 30
0N 10 20
</code></pre>
<p>For mixed lists, the first item is an empty list of the same type as the first item in the original list:</p>
<pre><code class="language-q">q)prev (10 20 30f;"hello";`blah)
`float$()
10 20 30f
"hello"
</code></pre>
<p><strong>Implementation</strong></p>
<p><code>prev</code> is effectively doing this:</p>
<pre><code class="language-q">(enlist x 0N),-1_x
</code></pre>
<h2 id="xprev"><a class="header" href="#xprev"><code>xprev</code></a></h2>
<p>The <code>xprev</code> keyword allows you to access the item <em>x</em> places before the current item in a list, padding with nulls where necessary.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">x xprev y
</code></pre>
<ul>
<li><code>x</code> : The number of positions to look back.</li>
<li><code>y</code> : The list from which to retrieve the previous items.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)2 xprev 10 20 30 40 50
0N 0N 10 20 30
</code></pre>
<p>For mixed lists, the first <em>x</em> items are empty lists of the same type as the first item in the original list:</p>
<pre><code class="language-q">q)2 xprev (10 20 30f;"hello";`blah;1 2 3f;101b)
`float$()
`float$()
10 20 30f
"hello"
`blah
</code></pre>
<p><strong>Implementation</strong></p>
<p>Conceptually, <code>xprev</code> performs the following:</p>
<pre><code class="language-q">y (til count y)-x
</code></pre>
<h2 id="rand"><a class="header" href="#rand"><code>rand</code></a></h2>
<p>The <code>rand</code> keyword is used to pick or generate a random value.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">rand x
</code></pre>
<ul>
<li><code>x</code> : A list (to select a random element) or a number (to generate a random number between 0 and <em>x</em>).</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)rand 10 20 30 40 50
50
q)rand 1000
360
</code></pre>
<p><code>rand</code> is a shorthand for the following:</p>
<pre><code class="language-q">first 1?x
</code></pre>
<p>While <code>rand</code> is convenient for generating a single random item, the <code>?</code> operator should be preferred for generating larger sets:</p>
<pre><code class="language-q">q)\ts rand each 1000000#10
626 41164880
q)\ts 1000000?10
19 8388800
</code></pre>
<h2 id="reciprocal"><a class="header" href="#reciprocal"><code>reciprocal</code></a></h2>
<p>The <code>reciprocal</code> keyword computes the reciprocal of a number or a list of numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">reciprocal x
</code></pre>
<ul>
<li><code>x</code> : A number or a list of numbers for which to compute the reciprocal.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)reciprocal 1 2 3 4 5
1 0.5 0.3333333 0.25 0.2
</code></pre>
<p>This operation is equivalent to applying the <code>%</code> operator with 1 as its left operand:</p>
<pre><code class="language-q">q)1%1 2 3 4 5
1 0.5 0.3333333 0.25 0.2
</code></pre>
<p>Both forms have similar performance:</p>
<pre><code class="language-q">q)\ts:100 reciprocal 1+til 10000000
4127 402660944

q)\ts:100 1%1+til 10000000
4070 402660384
</code></pre>
<p>While <code>reciprocal</code> is more verbose, <code>%</code> is often preferred for its succinctness and clarity.</p>
<h2 id="rload--rsave"><a class="header" href="#rload--rsave"><code>rload</code> &amp; <code>rsave</code></a></h2>
<p>The <code>rload</code> and <code>rsave</code> keywords are used to load and save splayed tables from and to directories, respectively.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">rload x
</code></pre>
<ul>
<li><code>x</code> : The directory path (as a symbol) from which to load a splayed table.</li>
</ul>
<pre><code class="language-q">rsave x
</code></pre>
<ul>
<li><code>x</code> : The directory path (as a symbol) to which a global table will be saved.</li>
</ul>
<p><strong>Example Usage</strong></p>
<p>In a fresh Q session, define and save a splayed <code>trade</code> table:</p>
<pre><code class="language-q">q)trade:update `sym?sym from flip `sym`price`qty!5?/:(`3;100f;100)

q)rsave `:db/trade
`:db/trade/
</code></pre>
<p>The <code>trade</code> table can be loaded using <code>rload</code>:</p>
<pre><code class="language-q">q)delete trade from `. // remove from memory
`.

q)rload `:db/trade
`trade
</code></pre>
<p><strong>Comparison: <code>rload</code> &amp; <code>rsave</code> vs <code>get</code> &amp; <code>set</code></strong></p>
<p><code>rload</code> and <code>rsave</code> are less flexible than the <code>get</code> and <code>set</code> keywords, which allow specifying different target directory names.</p>
<p>For example, saving with a different name using <code>set</code> and loading using <code>get</code>:</p>
<pre><code class="language-q">q)`:db/tradeOther/ set trade
`:db/tradeOther/

q)delete tradeOther from `.
`.

q)tradeOther:get `:db/tradeOther/
</code></pre>
<p><code>rload</code> and <code>rsave</code> also require global tables, whereas <code>get</code> and <code>set</code> can work with local tables.</p>
<pre><code class="language-q">q)f:{[] tradeLocal:update `sym?sym from flip `sym`price`qty!5?/:(`3;100f;100); rsave `:db/tradeLocal}

q)f[]
'tradeLocal
  [1]  f:{[] tradeLocal:update `sym?sym from flip `sym`price`qty!5?/:(`3;100f;100); rsave `:db/tradeLocal}
                                                                                    ^
</code></pre>
<pre><code class="language-q">q)f:{[] tradeLocal:update `sym?sym from flip `sym`price`qty!5?/:(`3;100f;100); `:db/tradeLocal/ set tradeLocal}

q)f[]
`:db/tradeLocal/
</code></pre>
<p>Implicit iteration is a benefit of <code>rload</code> and <code>rsave</code>:</p>
<pre><code class="language-q">q)t1:([] a:1 2 3; b:"abc")

q)t2:([] a:4 5 6; b:"def")

q)rsave `t1`t2
`:t1/`:t2/

q)delete t1, t2 from `.

q)rload `t1`t2
</code></pre>
<p>Explicit iteration is required with <code>get</code> and <code>set</code>:</p>
<pre><code class="language-q">q)`:t1/`:t2/ set' (t1;t2)
`:t1/`:t2/

q)get each `:t1`:t2
+`a`b!(1 2 3;"abc")
+`a`b!(4 5 6;"def")
</code></pre>
<p>If you don‚Äôt need the extra flexibility of <code>get</code> and <code>set</code>, <code>rload</code> and <code>rsave</code> offer a simpler method for saving and loading splayed tables.</p>
<h2 id="signum"><a class="header" href="#signum"><code>signum</code></a></h2>
<p>The <code>signum</code> keyword evaluates an integer value and returns:</p>
<ul>
<li><code>-1i</code> for a null or negative value</li>
<li><code>0i</code> for a zero value</li>
<li><code>1i</code> for a positive value</li>
</ul>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">signum x
</code></pre>
<ul>
<li><code>x</code> : An integer value.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)signum -1 0 1 0N
-1 0 1 -1i
</code></pre>
<p>You can use <code>signum</code> to categorise and count price movements by their direction:</p>
<pre><code class="language-q">q)t:([] price:10 11 9 8 8 15)

q)select ct:count i by direction:signum deltas price from t
direction| ct
---------| --
-1       | 2
0        | 1
1        | 3
</code></pre>
<p>This example demonstrates how <code>signum</code> can be used to summarise directional price changes in a dataset.</p>
<h2 id="sublist"><a class="header" href="#sublist"><code>sublist</code></a></h2>
<p>The <code>sublist</code> keyword selects a subset of a list.</p>
<p><strong>Syntax</strong></p>
<pre><code class="language-q">x sublist y
</code></pre>
<ul>
<li><code>x</code> : The number of items to take from the start of the list if positive, or from the end if negative.</li>
<li><code>y</code> : The list from which to extract the sublist.</li>
</ul>
<p><strong>Example Usage</strong></p>
<pre><code class="language-q">q)3 sublist 10 20 30 40 50
10 20 30

q)-3 sublist 10 20 30 40 50
30 40 50
</code></pre>
<p>If the requested sublist exceeds the available items, it returns as many items as possible:</p>
<pre><code class="language-q">q)10 sublist 10 20 30 40 50
10 20 30 40 50
</code></pre>
<p>You can also select a slice of the list:</p>
<pre><code class="language-q">q)1 3 sublist 10 20 30 40 50
20 30 40

q)1 10 sublist 10 20 30 40 50
20 30 40 50
</code></pre>
<p><strong>Comparison: <code>sublist</code> vs take (<code>#</code>)</strong></p>
<p>Use <code>sublist</code> when you want to avoid exceeding the number of available items, unlike the <code>#</code> operator which always returns the requested number of items:</p>
<pre><code class="language-q">q)10#"Hey"
"HeyHeyHeyH"

q)10 sublist "Hey"
"Hey"
</code></pre>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>In the Q programming language, while some keywords are well-known and frequently used, there are others that, though lesser-known, offer powerful functionality that can simplify and optimise your code. From efficient data-saving methods with <code>dsave</code>, to navigating lists with <code>next</code>, <code>prev</code>, and <code>xprev</code>, and managing splayed tables with <code>rload</code> and <code>rsave</code>, these keywords may seem minor at first glance, but they can make a significant difference in your code‚Äôs clarity and maintainability.</p>
<p>However, not all keywords are equally valuable in every context. For instance, the <code>csv</code> keyword, a shorthand for comma-delimited text, might be less useful in modern coding practices where other delimiters are also prevalent. Similarly, while <code>reciprocal</code> provides a way to calculate the reciprocal of a number, the more concise <code>1%</code> is usually preferred for its brevity and clarity.</p>
<p>Understanding and utilising these underappreciated keywords not only enhances your proficiency in Q but also opens up new possibilities for writing more readable, efficient, and maintainable code. So, the next time you‚Äôre coding in Q, consider reaching for these keywords ‚Äì they might just become your new favourites.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="analysis-of-q-memory-allocation"><a class="header" href="#analysis-of-q-memory-allocation">Analysis of Q Memory Allocation</a></h1>
<p><img src="images/analysis_of_q_memory_allocation.png" title="Cover Image" alt="Cover Image"></p>
<p>Memory allocation is a crucial aspect of any programming language, affecting performance and resource management. This blog delves into how the Q programming language handles memory allocation using the buddy memory allocation system.</p>
<h2 id="buddy-memory-allocation-in-q"><a class="header" href="#buddy-memory-allocation-in-q">Buddy Memory Allocation in Q</a></h2>
<p>Q uses a form of <a href="https://en.wikipedia.org/wiki/Buddy_memory_allocation">buddy memory allocation</a> for its memory management. Memory is requested in chunks whose sizes are powers of two, regardless of the actual memory required by an object.</p>
<p>For instance, if an object needs 1,000 bytes, a block of 1,024 bytes (\(2^{10}\)) will be allocated. If the object grows to need 1,025 bytes, the allocated block size will increase to 2,048 bytes (\(2^{11}\)). This system allows efficient memory usage by minimising the frequency of allocations as objects grow.</p>
<h2 id="list-memory-usage"><a class="header" href="#list-memory-usage">List Memory Usage</a></h2>
<p>A long integer in Q is an 8-byte value. Thus, a list of <em>N</em> long integers requires \(8 \times N\) bytes of memory. We can use the <code>-22!</code> command to check the uncompressed length (in bytes) of a list.</p>
<p><strong>Example</strong></p>
<p>Creating a list of 10,000,000 long integers and viewing its memory usage:</p>
<pre><code class="language-q">q)mylist:til 10000000

q)-22!mylist 
80000014
</code></pre>
<p>The list requires 80,000,014 bytes. The extra 14 bytes store metadata about the list, such as type, count, reference count, and attributes. This overhead is consistent across lists in Q.</p>
<pre><code class="language-q">// A list of 2 longs : (2 * 8) + 14 = 30
q)-22!til 2
30

// A list of 5 chars : (5 * 1) + 14 = 19
q)-22!"hello"
19
</code></pre>
<h2 id="heap-allocation"><a class="header" href="#heap-allocation">Heap Allocation</a></h2>
<h3 id="initial-memory-usage"><a class="header" href="#initial-memory-usage">Initial Memory Usage</a></h3>
<p>In a fresh Q session, we can check the initial used and heap memory:</p>
<pre><code class="language-q">q)show before:`used`heap#.Q.w[]
used| 362736
heap| 67108864
</code></pre>
<ul>
<li>
<p><strong>Used Memory</strong>: Total memory currently used by all defined objects in the Q process, including internal structures.</p>
</li>
<li>
<p><strong>Heap Memory</strong>: Total system memory allocated to the Q process, initially 64 MB (\(2^{26}\) bytes).</p>
</li>
</ul>
<h3 id="dynamic-memory-allocation"><a class="header" href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></h3>
<p>As memory demands increase, the heap size will adjust accordingly. For instance, creating a list of 10,000,000 longs:</p>
<pre><code class="language-q">q)mylist:til 10000000

q)show after:`used`heap#.Q.w[]
used| 134580608
heap| 201326592
</code></pre>
<p>The heap size increased to accommodate the list. The heap size formula in Q is:</p>
<p>\[
2^{26} + 2^{n} \times x
\]</p>
<p>where \(n \ge 26\) and <em>x</em> is 0 or 1 depending on whether the initial memory is sufficient or not.</p>
<h3 id="example-calculation"><a class="header" href="#example-calculation">Example Calculation</a></h3>
<p>Creating a list of 10,000,000 longs requires 80,000,014 bytes. Initially, the heap size is 64 MB. After creating the list, the heap increases to 192 MB, i.e., \(2^{26} + 2^{27}\) bytes.</p>
<h2 id="used-allocation"><a class="header" href="#used-allocation">Used Allocation</a></h2>
<p>Used memory represents the actual memory required by objects, while allocated blocks follow the buddy system.</p>
<p><strong>Example</strong></p>
<p>Comparing memory before and after list creation:</p>
<pre><code class="language-q">q)after-before
used| 134217872
heap| 134217728
</code></pre>
<p>The increase in used memory by 134,217,872 bytes indicates the buddy system‚Äôs allocation, where the block size must be a power of two, plus some overhead and memory to store the <code>before</code> dictionary (\(134,217,872 = 134,217,728 + 144\), where the 144 bytes is the overhead to store the <code>before</code> dictionary).</p>
<h2 id="object-reserved-memory"><a class="header" href="#object-reserved-memory">Object Reserved Memory</a></h2>
<p>Q reserves memory blocks as powers of two for objects, allowing efficient growth without frequent reallocations.</p>
<p><strong>Example</strong></p>
<p>Appending 1,000,000 longs to a list of 10,000,000 longs:</p>
<pre><code class="language-q">q)mylist:til 10000000

q)show before:`used`heap#.Q.w[]
used| 134580512
heap| 201326592

q)mylist,:til 1000000

q)show after:`used`heap#.Q.w[]
used| 134580608
heap| 201326592

q)after-before
used| 96
heap| 0
</code></pre>
<p>The used memory barely changes, as the additional longs fit into the reserved memory of the list.</p>
<h3 id="new-list-allocation"><a class="header" href="#new-list-allocation">New List Allocation</a></h3>
<p>If we create a new list, Q must allocate a different memory block for it, causing a significant increase in used memory:</p>
<pre><code class="language-q">q)newlist:til 1000000

q)show afterNewList:`used`heap#.Q.w[];
used| 142968208
heap| 201326592

q)afterNewList-after
used| 8387600
heap| 0
</code></pre>
<p>The creation of <code>newlist</code> increases the used memory by 8,387,600 bytes, reflecting the allocation of a new memory block.</p>
<h2 id="releasing-reserved-memory"><a class="header" href="#releasing-reserved-memory">Releasing Reserved Memory</a></h2>
<p>Clearing data from an object releases its memory back to the heap.</p>
<p><strong>Example</strong></p>
<p>Clearing a list:</p>
<pre><code class="language-q">q)mylist:til 10000000

q)show before:`used`heap#.Q.w[]
used| 134579200
heap| 201326592

q)mylist:0#mylist

q)show after:`used`heap#.Q.w[]
used| 361584
heap| 201326592

q)after-before
used| -134217616
heap| 0
</code></pre>
<p>The used memory returns to its initial state.</p>
<h2 id="garbage-collection"><a class="header" href="#garbage-collection">Garbage Collection</a></h2>
<p>Q‚Äôs default garbage collection mode is deferred, meaning it triggers in two cases:</p>
<ul>
<li><code>.Q.gc[]</code> is called manually.</li>
<li>Memory limit is hit (set with <code>-w</code> on the command line).</li>
</ul>
<p>It is important to think about how certain operations in Q work behind the scenes when it comes to memory.</p>
<p>When we join items to a list using the join operator (<code>,</code>) Q will copy data from one list to the other. Therefore, at some stage, we will have two copies of the list, requiring double the memory of the original list to perform the operation.</p>
<p><strong>Example</strong></p>
<p>In a fresh Q session, we create an empty list of longs, then join 10,000,000 longs:</p>
<pre><code class="language-q">q)mylist:"j"$()

q)show before:`used`heap#.Q.w[]
used| 362800
heap| 67108864

q)\ts mylist,:til 10000000
28 268435680

q)show after:`used`heap#.Q.w[]
used| 134580608
heap| 335544320
</code></pre>
<p>Previously, a heap size of 201,326,592 bytes was enough to accommodate our list of 10,000,000 longs. However, at one point in the join operation we will have two copies of 10,000,000 longs (20,000,000 longs in total). Therefore, we require more memory. Using the <code>\ts</code> command confirms this by showing us that the join operation used 268,435,680 bytes of memory to perform.</p>
<p>After this operation, the heap is unnecessarily big, consuming system resources that we do not need. We can release this unused memory back to the OS by invoking <code>.Q.gc[]</code>:</p>
<pre><code class="language-q">q).Q.gc[] // Manual garbage collection
134217728

q)show afterGC:`used`heap#.Q.w[]
used| 134579456
heap| 201326592
</code></pre>
<p>The heap size reduces after garbage collection, freeing up system resources.</p>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>Understanding memory allocation in Q, particularly through the buddy memory allocation system, provides insight into efficient memory management and helps in optimising performance. The examples illustrate how Q handles memory for lists, the impact of heap allocation, and the benefits of manual garbage collection. Moreover, it is essential to consider how operations like joining lists impact memory usage, potentially doubling the memory required during the operation and necessitating periodic garbage collection to free up resources.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-2c2089fd.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/navigation-8d154390.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
